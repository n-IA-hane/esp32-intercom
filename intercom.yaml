# =============================================================================
# ESP32-S3 UDP INTERCOM - Full Duplex Audio with Home Assistant
# =============================================================================
# Hardware: Xiaozhi Ball V3 (ESP32-S3 + ES8311 codec + GC9A01A display)
# Protocol: Raw PCM 16-bit, 16kHz, mono over UDP
# TX: ESP32 -> Home Assistant on port 12345
# RX: Home Assistant -> ESP32 on port 12346
#
# Created by Claude (Anthropic) for n-IA-hane
# https://github.com/n-IA-hane/esp32-intercom
# =============================================================================

substitutions:
  name: intercom
  friendly_name: Intercom

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.5.0
  name_add_mac_suffix: false
  on_boot:
    priority: 600
    then:
      - lambda: id(boot_complete) = false;
      - delay: 3s
      - lambda: id(boot_complete) = true;
      - lambda: |-
          // Apply saved volume on boot (same curve as set_action)
          float x = id(speaker_volume).state;
          float vol;
          if (x <= 0) {
            vol = 0.0;
          } else {
            vol = 0.15 + (x / 100.0) * 0.60;
          }
          id(es8311_dac).set_volume(vol);
          ESP_LOGI("boot", "Applied saved volume: %.0f%% -> DAC %.2f", x, vol);

          // Apply saved AEC state
          id(intercom_component).set_aec_enabled(id(aec_switch).state);
          ESP_LOGI("boot", "AEC state: %s", id(aec_switch).state ? "ON" : "OFF");

          // Sync operating mode from restored select value
          auto mode = id(operating_mode).state;
          if (mode == "P2P Auto Answer") {
            id(intercom_component).set_operating_mode(udp_intercom::OPERATING_MODE_P2P);
            id(intercom_component).set_p2p_auto_answer(true);
            ESP_LOGI("boot", "Mode synced: P2P Auto Answer");
          } else if (mode == "P2P") {
            id(intercom_component).set_operating_mode(udp_intercom::OPERATING_MODE_P2P);
            id(intercom_component).set_p2p_auto_answer(false);
            ESP_LOGI("boot", "Mode synced: P2P");
          } else {
            id(intercom_component).set_operating_mode(udp_intercom::OPERATING_MODE_GO2RTC);
            id(intercom_component).set_p2p_auto_answer(false);
            ESP_LOGI("boot", "Mode synced: go2rtc");
          }
      - component.update: main_display

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
    # ESP-SR for Acoustic Echo Cancellation (AFE)
    components:
      - espressif/esp-sr^2.3.0

psram:
  mode: octal
  speed: 80MHz

# =============================================================================
# CONNECTIVITY
# =============================================================================
api:
  id: api_server

ota:
  - platform: esphome

logger:
  hardware_uart: USB_SERIAL_JTAG
  level: DEBUG

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  # use_address: 192.168.1.31  # Uncomment and set your static IP
  ap:
    ssid: "Intercom Fallback"

# =============================================================================
# mDNS SERVICE FOR P2P DISCOVERY
# =============================================================================
mdns:
  services:
    - service: "_udp-intercom"
      protocol: "_udp"
      port: 12346
      txt:
        device: ${name}
        type: "intercom"

# =============================================================================
# I2C FOR ES8311 CODEC CONTROL
# =============================================================================
i2c:
  sda: GPIO15
  scl: GPIO14
  scan: true
  id: bus_a

# ES8311 DAC configuration via I2C (volume control)
audio_dac:
  - platform: es8311
    id: es8311_dac
    bits_per_sample: 16bit
    sample_rate: 16000

# =============================================================================
# UDP INTERCOM COMPONENT (Direct I2S Full Duplex)
# =============================================================================
external_components:
  - source:
      type: local
      path: custom_components

udp_intercom:
  id: intercom_component

  # ─────────────────────────────────────────────────────────────────────────
  # I2S Configuration - SINGLE BUS MODE (ES8311 codec)
  # ─────────────────────────────────────────────────────────────────────────
  i2s_mode: single
  sample_rate: 16000
  i2s_lrclk_pin: GPIO45
  i2s_bclk_pin: GPIO9
  i2s_mclk_pin: GPIO16
  i2s_din_pin: GPIO10            # Microphone data in
  i2s_dout_pin: GPIO8            # Speaker data out
  speaker_enable_pin: GPIO46

  # ─────────────────────────────────────────────────────────────────────────
  # Network - go2rtc mode (default)
  # ─────────────────────────────────────────────────────────────────────────
  server_ip: "192.168.1.10"      # Your Home Assistant IP
  server_port: 12345             # UDP port for mic audio (ESP32 -> HA)
  listen_port: 12346             # UDP port for speaker audio (HA -> ESP32)

  # ─────────────────────────────────────────────────────────────────────────
  # P2P Mode - For walkie-talkie with other ESP devices
  # ─────────────────────────────────────────────────────────────────────────
  p2p_enabled: true
  p2p_service_name: "udp-intercom"
  p2p_auto_answer: false         # Xiaozhi has buttons, no auto-answer
  p2p_timeout: 30s               # Longer timeout for manual hangup

  # ─────────────────────────────────────────────────────────────────────────
  # Audio Processing
  # ─────────────────────────────────────────────────────────────────────────
  aec_enabled: true              # ES8311 with PSRAM octal supports AEC
  volume_mode: hardware          # Use ES8311 hardware DAC for volume

  # ─────────────────────────────────────────────────────────────────────────
  # Triggers
  # ─────────────────────────────────────────────────────────────────────────
  on_ring:
    - homeassistant.event:
        event: esphome.doorbell_ring
        data:
          device: ${name}
    - lambda: id(main_display).update();
    # Blinking orange LED for ringing
    - light.turn_on:
        id: status_led
        brightness: 100%
        red: 1
        green: 0.6
        blue: 0
        effect: "Fast Pulse"
  on_call_start:
    - lambda: |-
        id(countdown_seconds) = 60;  // Reset countdown on call start
        id(main_display).update();
    # Solid green LED for streaming
    - light.turn_on:
        id: status_led
        brightness: 100%
        red: 0
        green: 1
        blue: 0
        effect: "None"
  on_call_end:
    - lambda: id(main_display).update();
    # Turn off LED when call ends
    - light.turn_off: status_led
  on_peer_discovered:
    - logger.log:
        format: "Peer discovered: %s at %s"
        args: ["name.c_str()", "ip.c_str()"]
    # Auto-fill the target IP with the first discovered peer
    - lambda: |-
        if (id(manual_peer_ip).state.empty()) {
          auto call = id(manual_peer_ip).make_call();
          call.set_value(ip);
          call.perform();
          ESP_LOGI("p2p", "Auto-set target IP to discovered peer: %s", ip.c_str());
        }
    - lambda: id(main_display).update();
  on_peer_lost:
    - logger.log:
        format: "Peer lost: %s"
        args: ["name.c_str()"]
    # If the lost peer was selected, switch to another available peer
    - lambda: |-
        std::string current_ip = id(manual_peer_ip).state;
        auto& peers = id(intercom_component).get_peers();
        bool found = false;
        for (const auto& peer : peers) {
          if (peer.ip == current_ip) {
            found = true;
            break;
          }
        }
        if (!found) {
          if (!peers.empty()) {
            auto call = id(manual_peer_ip).make_call();
            call.set_value(peers[0].ip);
            call.perform();
            ESP_LOGI("p2p", "Peer lost, switched to: %s (%s)", peers[0].name.c_str(), peers[0].ip.c_str());
          } else {
            auto call = id(manual_peer_ip).make_call();
            call.set_value("");
            call.perform();
            ESP_LOGI("p2p", "No peers available");
          }
        }
    - lambda: id(main_display).update();

# =============================================================================
# SENSORS
# =============================================================================
sensor:
  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_db
    update_interval: 10s
    entity_category: diagnostic

  - platform: template
    name: "TX Packets"
    id: tx_packets
    accuracy_decimals: 0
    update_interval: 1s
    lambda: return id(intercom_component).get_tx_packets();
    entity_category: diagnostic

  - platform: template
    name: "RX Packets"
    id: rx_packets
    accuracy_decimals: 0
    update_interval: 1s
    lambda: return id(intercom_component).get_rx_packets();
    entity_category: diagnostic

  - platform: template
    name: "Peer Count"
    id: peer_count
    accuracy_decimals: 0
    update_interval: 5s
    lambda: return id(intercom_component).get_peer_count();
    entity_category: diagnostic

text_sensor:
  - platform: template
    name: "Intercom State"
    id: intercom_state_text
    update_interval: 1s
    lambda: |-
      auto state = id(intercom_component).get_state();
      // Returns translated state text - wrap in std::string for ESPHome
      return {std::string(id(intercom_component).get_state_text(state))};

  - platform: template
    name: "Current Peer"
    id: current_peer_text
    icon: "mdi:account-check"
    update_interval: 2s
    lambda: |-
      std::string target_ip = id(manual_peer_ip).state;
      if (target_ip.empty()) return std::string("(nessuno)");
      auto& peers = id(intercom_component).get_peers();
      for (const auto& peer : peers) {
        if (peer.ip == target_ip) {
          return peer.name + " (" + peer.ip + ")";
        }
      }
      return std::string("IP: ") + target_ip;

  - platform: template
    name: "Discovered Peers"
    id: discovered_peers_text
    update_interval: 5s
    entity_category: diagnostic
    lambda: |-
      int count = id(intercom_component).get_peer_count();
      if (count == 0) return std::string("No peers found");
      std::string result;
      auto& peer_list = id(intercom_component).get_peers();
      for (size_t i = 0; i < peer_list.size(); i++) {
        if (i > 0) result += ", ";
        result += peer_list[i].name + " (" + peer_list[i].ip + ")";
      }
      return result;

# =============================================================================
# BINARY SENSORS
# =============================================================================
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    id: doorbell_button
    name: "Doorbell Button"
    on_press:
      - udp_intercom.ring_doorbell:
          id: intercom_component
    on_multi_click:
      - timing:
          - ON for at least 3s
        then:
          - udp_intercom.stop_streaming:
              id: intercom_component

  - platform: template
    name: "Call Active"
    id: call_active
    lambda: return id(intercom_component).is_streaming();

  # Touch sensor on display - resets countdown when touched
  - platform: gpio
    pin:
      number: GPIO12
      mode: INPUT_PULLUP
      inverted: true
    id: touch_input
    name: "Display Touch"
    on_press:
      then:
        - if:
            condition:
              lambda: return id(intercom_component).is_streaming();
            then:
              - lambda: |-
                  id(countdown_seconds) = 60;
                  ESP_LOGI("touch", "Countdown reset by touch");

# =============================================================================
# SWITCHES
# =============================================================================
switch:
  - platform: template
    name: "Streaming"
    id: streaming_switch
    icon: "mdi:phone"
    turn_on_action:
      - lambda: id(countdown_seconds) = 60;  # Reset countdown
      - udp_intercom.start_streaming:
          id: intercom_component
    turn_off_action:
      - udp_intercom.stop_streaming:
          id: intercom_component
    lambda: return id(intercom_component).is_streaming();

  - platform: template
    name: "Echo Cancellation"
    id: aec_switch
    icon: "mdi:microphone-off"
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
    turn_on_action:
      - lambda: |-
          id(intercom_component).set_aec_enabled(true);
          ESP_LOGI("aec", "Echo Cancellation ENABLED (restart streaming to apply)");
    turn_off_action:
      - lambda: |-
          id(intercom_component).set_aec_enabled(false);
          ESP_LOGI("aec", "Echo Cancellation DISABLED (restart streaming to apply)");

# =============================================================================
# SELECT FOR OPERATING MODE AND HANGUP MODE
# =============================================================================
select:
  - platform: template
    name: "Operating Mode"
    id: operating_mode
    icon: "mdi:swap-horizontal"
    optimistic: true
    restore_value: true
    options:
      - "go2rtc"
      - "P2P"
      - "P2P Auto Answer"
    initial_option: "go2rtc"
    set_action:
      - lambda: |-
          if (x == "P2P Auto Answer") {
            id(intercom_component).set_operating_mode(udp_intercom::OPERATING_MODE_P2P);
            id(intercom_component).set_p2p_auto_answer(true);
            ESP_LOGI("mode", "Operating mode: P2P Auto Answer");
          } else if (x == "P2P") {
            id(intercom_component).set_operating_mode(udp_intercom::OPERATING_MODE_P2P);
            id(intercom_component).set_p2p_auto_answer(false);
            ESP_LOGI("mode", "Operating mode: P2P (manual answer)");
          } else {
            id(intercom_component).set_operating_mode(udp_intercom::OPERATING_MODE_GO2RTC);
            id(intercom_component).set_p2p_auto_answer(false);
            ESP_LOGI("mode", "Operating mode: go2rtc");
          }

  - platform: template
    name: "Hangup Mode"
    id: hangup_mode
    icon: "mdi:phone-hangup"
    optimistic: true
    restore_value: true
    options:
      - "Automatic"
      - "Manual"
    initial_option: "Automatic"

# =============================================================================
# TEXT INPUT FOR MANUAL PEER IP
# =============================================================================
text:
  - platform: template
    name: "Target IP"
    id: manual_peer_ip
    icon: "mdi:ip-network"
    optimistic: true
    restore_value: true
    initial_value: ""
    mode: text
    min_length: 0
    max_length: 15

# =============================================================================
# INTERVAL FOR COUNTDOWN AND BLINKING
# =============================================================================
interval:
  - interval: 500ms
    then:
      - lambda: |-
          // Toggle blink state for RINGING text animation
          id(blink_state) = !id(blink_state);
  - interval: 1s
    then:
      - lambda: |-
          // Countdown logic when streaming and hangup mode is "Automatic"
          if (id(intercom_component).is_streaming() && id(hangup_mode).state == "Automatic") {
            if (id(countdown_seconds) > 0) {
              id(countdown_seconds) -= 1;
              ESP_LOGD("countdown", "Countdown: %d seconds", id(countdown_seconds));
            }
            if (id(countdown_seconds) <= 0) {
              ESP_LOGI("countdown", "Auto hangup triggered!");
              id(intercom_component).stop_streaming();
            }
          }

# =============================================================================
# SPEAKER VOLUME CONTROL
# =============================================================================
number:
  - platform: template
    name: "Speaker Volume"
    id: speaker_volume
    min_value: 0
    max_value: 100
    step: 5
    initial_value: 50
    optimistic: true
    restore_value: true
    unit_of_measurement: "%"
    icon: "mdi:volume-high"
    set_action:
      - lambda: |-
          // Map 0-100% to usable DAC range (0.15 - 0.75)
          // 0% -> 0 (mute), 1-100% -> 0.15-0.75
          float vol;
          if (x <= 0) {
            vol = 0.0;  // True mute
          } else {
            vol = 0.15 + (x / 100.0) * 0.60;
          }
          id(es8311_dac).set_volume(vol);
          ESP_LOGI("volume", "Speaker volume: %.0f%% -> DAC %.2f", x, vol);

# =============================================================================
# BUTTONS
# =============================================================================
button:
  - platform: template
    name: "Ring Doorbell"
    icon: "mdi:bell-ring"
    on_press:
      - udp_intercom.ring_doorbell:
          id: intercom_component

  - platform: template
    name: "Extend Call"
    icon: "mdi:timer-plus"
    on_press:
      - lambda: |-
          id(countdown_seconds) = 60;
          ESP_LOGI("countdown", "Countdown reset to 60 seconds");

  - platform: template
    name: "Reset Counters"
    icon: "mdi:counter"
    entity_category: diagnostic
    on_press:
      - lambda: id(intercom_component).reset_counters();

  - platform: template
    name: "Refresh Peers"
    icon: "mdi:refresh"
    on_press:
      - udp_intercom.refresh_peers:
          id: intercom_component

  - platform: template
    name: "Next Peer"
    icon: "mdi:account-arrow-right"
    on_press:
      - lambda: |-
          auto& peers = id(intercom_component).get_peers();
          if (peers.empty()) {
            ESP_LOGW("peer", "No peers discovered");
            return;
          }
          std::string current_ip = id(manual_peer_ip).state;
          int current_idx = -1;
          for (size_t i = 0; i < peers.size(); i++) {
            if (peers[i].ip == current_ip) {
              current_idx = i;
              break;
            }
          }
          int next_idx = (current_idx + 1) % peers.size();
          auto& next_peer = peers[next_idx];
          auto call = id(manual_peer_ip).make_call();
          call.set_value(next_peer.ip);
          call.perform();
          ESP_LOGI("peer", "Selected peer %d/%d: %s (%s)",
                   next_idx + 1, peers.size(), next_peer.name.c_str(), next_peer.ip.c_str());

# =============================================================================
# OUTPUT & LIGHTS
# =============================================================================
output:
  - platform: ledc
    pin: GPIO42
    id: backlight_output
    inverted: true

light:
  - platform: monochromatic
    id: screen_backlight
    name: "Screen Backlight"
    output: backlight_output
    restore_mode: ALWAYS_ON
    default_transition_length: 250ms

  - platform: esp32_rmt_led_strip
    id: status_led
    name: "Status LED"
    pin: GPIO48
    chipset: WS2812
    num_leds: 1
    rgb_order: grb
    effects:
      - pulse:
          name: "Fast Pulse"
          transition_length: 0.3s
          update_interval: 0.3s
          min_brightness: 0%
          max_brightness: 100%

# =============================================================================
# GLOBALS
# =============================================================================
globals:
  - id: boot_complete
    type: bool
    restore_value: false
    initial_value: "false"
  - id: countdown_seconds
    type: int
    restore_value: false
    initial_value: "60"
  - id: blink_state
    type: bool
    restore_value: false
    initial_value: "true"

# =============================================================================
# FONTS
# =============================================================================
font:
  - file:
      type: gfonts
      family: Roboto
      weight: 700
    id: font_title
    size: 24
  - file:
      type: gfonts
      family: Roboto
      weight: 500
    id: font_state
    size: 32
  - file:
      type: gfonts
      family: Roboto Mono
      weight: 400
    id: font_debug
    size: 14

# =============================================================================
# COLORS
# =============================================================================
color:
  # Background colors
  - id: color_idle
    hex: "2196F3"     # Blue background
  - id: color_ringing
    hex: "FF9800"     # Orange background
  - id: color_streaming
    hex: "4CAF50"     # Green background
  - id: color_error
    hex: "F44336"     # Red background
  # Text colors
  - id: color_text_idle
    hex: "00FF00"     # Green text for IDLE
  - id: color_text_ringing
    hex: "0080FF"     # Blue text for RINGING
  - id: color_text_streaming
    hex: "FF0000"     # Red text for STREAMING
  - id: color_white
    hex: "FFFFFF"
  - id: color_gray
    hex: "888888"
  - id: color_black
    hex: "000000"

# =============================================================================
# DISPLAY (GC9A01A 240x240 round)
# =============================================================================
spi:
  - id: spi_bus
    clk_pin: GPIO4
    mosi_pin: GPIO2

display:
  - platform: ili9xxx
    id: main_display
    model: GC9A01A
    invert_colors: true
    data_rate: 40MHz
    cs_pin: GPIO5
    dc_pin: GPIO47
    reset_pin: GPIO38
    update_interval: 250ms
    dimensions:
      height: 240
      width: 240
    lambda: |-
      const int w = it.get_width();
      const int h = it.get_height();
      const int cx = w / 2;
      const int cy = h / 2;

      // Get current state
      auto state = id(intercom_component).get_state();

      // Background and text colors based on state
      Color bg_color;
      Color text_color;
      const char* state_text = id(intercom_component).get_state_text(state);
      bool is_streaming = false;

      switch (state) {
        case udp_intercom::INTERCOM_STATE_IDLE:
          bg_color = id(color_idle);
          text_color = id(color_text_idle);      // Green text
          break;
        case udp_intercom::INTERCOM_STATE_RINGING:
          bg_color = id(color_ringing);
          text_color = id(color_text_ringing);   // Blue text (will blink)
          break;
        case udp_intercom::INTERCOM_STATE_STREAMING_DUPLEX:
        case udp_intercom::INTERCOM_STATE_STREAMING_IN:
        case udp_intercom::INTERCOM_STATE_STREAMING_OUT:
          bg_color = id(color_streaming);
          text_color = id(color_text_streaming); // Red text
          is_streaming = true;
          break;
        case udp_intercom::INTERCOM_STATE_ERROR:
          bg_color = id(color_error);
          text_color = id(color_white);
          break;
        default:
          bg_color = id(color_gray);
          text_color = id(color_white);
      }

      it.fill(bg_color);

      // Title "INTERCOM" at top
      it.print(cx, 30, id(font_title), id(color_white), TextAlign::CENTER, "INTERCOM");

      // State text in center - blink if RINGING
      if (state == udp_intercom::INTERCOM_STATE_RINGING) {
        // Blinking text for RINGING
        if (id(blink_state)) {
          it.print(cx, cy, id(font_state), text_color, TextAlign::CENTER, state_text);
        }
        // When blink_state is false, don't print (text disappears)
      } else {
        it.print(cx, cy, id(font_state), text_color, TextAlign::CENTER, state_text);
      }

      // Show countdown when streaming and hangup mode is "Automatic"
      if (is_streaming && id(hangup_mode).state == "Automatic") {
        char countdown_buf[16];
        int secs = id(countdown_seconds);
        snprintf(countdown_buf, sizeof(countdown_buf), "Auto: %02d:%02d", secs / 60, secs % 60);
        it.print(cx, cy + 35, id(font_debug), id(color_white), TextAlign::CENTER, countdown_buf);
      }

      // Debug info at bottom
      char buf[32];
      snprintf(buf, sizeof(buf), "TX:%lu RX:%lu",
               (unsigned long)id(intercom_component).get_tx_packets(),
               (unsigned long)id(intercom_component).get_rx_packets());
      it.print(cx, h - 55, id(font_debug), id(color_white), TextAlign::CENTER, buf);

      // WiFi signal
      float wifi_pct = 0;
      if (id(wifi_signal_db).has_state()) {
        float dbm = id(wifi_signal_db).state;
        if (dbm >= -50) wifi_pct = 100;
        else if (dbm <= -100) wifi_pct = 0;
        else wifi_pct = 2 * (dbm + 100);
      }
      snprintf(buf, sizeof(buf), "WiFi: %.0f%%", wifi_pct);
      it.print(cx, h - 35, id(font_debug), id(color_white), TextAlign::CENTER, buf);

      // API status
      const char* api_status = id(api_server).is_connected() ? "HA: OK" : "HA: DISC";
      it.print(cx, h - 15, id(font_debug), id(color_white), TextAlign::CENTER, api_status);
