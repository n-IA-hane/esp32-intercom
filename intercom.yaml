# ==============================================================================
# ESP32-S3 UDP INTERCOM - Xiaozhi Ball V3 (ES8311 Codec + GC9A01A Display)
# ==============================================================================
#
# OVERVIEW:
# Full-featured intercom device with audio codec, round LCD display, and RGB LED.
# Supports bidirectional audio streaming via UDP with P2P discovery using mDNS.
#
# HARDWARE:
# - Board: Xiaozhi Ball V3 (ESP32-S3 with 16MB Flash + PSRAM)
# - Audio: ES8311 I2S codec (single bus for mic + speaker)
# - Display: GC9A01A 240x240 round LCD (SPI)
# - LED: WS2812 RGB status indicator
# - Input: Capacitive touch + physical button
#
# COMPONENTS USED:
# - i2s_audio_udp: Core audio streaming over UDP
# - mdns_discovery: Automatic peer discovery on local network
# - esp_aec: Echo cancellation (optional, currently disabled)
#
# OPERATING MODES:
# - go2rtc: Connect to go2rtc server on Home Assistant for WebRTC bridging
# - P2P: Direct peer-to-peer audio streaming
# - P2P Auto Answer: P2P mode with automatic call answering
#
# SIGNALING PROTOCOL (UDP port 12350):
# - CALL:device_name:device_ip:target_name  - Initiate call to target
# - HANGUP:device_name:device_ip            - Terminate active call
#
# Repository: https://github.com/n-IA-hane/esphome-intercom
# ==============================================================================

# ------------------------------------------------------------------------------
# SUBSTITUTIONS
# Define device-specific variables used throughout the configuration
# ------------------------------------------------------------------------------
substitutions:
  name: intercom                    # Device hostname and entity prefix
  friendly_name: Intercom           # Human-readable name in Home Assistant
  ha_ip: "192.168.1.10"             # Home Assistant IP (for go2rtc mode)
  go2rtc_port: "12345"              # go2rtc server UDP port
  p2p_port: "12346"                 # P2P audio streaming port

# ------------------------------------------------------------------------------
# ESPHOME CORE CONFIGURATION
# ------------------------------------------------------------------------------
esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.5.0
  name_add_mac_suffix: false
  on_boot:
    priority: 600
    then:
      # Mark boot sequence in progress
      - lambda: id(boot_complete) = false;
      - delay: 3s
      - lambda: id(boot_complete) = true;
      # Restore saved speaker volume from flash
      - lambda: |-
          float x = id(speaker_volume).state;
          float vol;
          if (x <= 0) {
            vol = 0.0;
          } else {
            // Map 0-100% to 0.15-0.75 DAC range (ES8311 optimal range)
            vol = 0.15 + (x / 100.0) * 0.60;
          }
          id(es8311_dac).set_volume(vol);
          ESP_LOGI("boot", "Applied saved volume: %.0f%% -> DAC %.2f", x, vol);
      - component.update: main_display

# ------------------------------------------------------------------------------
# ESP32-S3 PLATFORM CONFIGURATION
# ------------------------------------------------------------------------------
esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
    # ESP-AEC requires ESP-SR component (installation pending)
    # components:
    #   - espressif/esp-sr^2.3.0

# PSRAM configuration for audio buffers
psram:
  mode: octal
  speed: 80MHz

# ==============================================================================
# CONNECTIVITY
# ==============================================================================

# Home Assistant API connection
api:
  id: api_server

# Over-the-air updates
ota:
  - platform: esphome

# Web-based configuration interface
web_server:
  port: 80

# Serial logging via USB (ESP32-S3 native USB)
logger:
  hardware_uart: USB_SERIAL_JTAG
  level: DEBUG

# WiFi configuration
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Intercom Fallback"

# ==============================================================================
# mDNS SERVICE ADVERTISEMENT
# Advertise this device as an intercom peer for automatic discovery
# ==============================================================================
mdns:
  services:
    - service: "_udp-intercom"
      protocol: "_udp"
      port: 12346
      txt:
        device: ${name}
        type: "intercom"

# ==============================================================================
# I2C BUS - ES8311 Codec Control Interface
# ==============================================================================
i2c:
  sda: GPIO15
  scl: GPIO14
  scan: true
  id: bus_a

# ES8311 Audio DAC/ADC codec configuration
audio_dac:
  - platform: es8311
    id: es8311_dac
    bits_per_sample: 16bit
    sample_rate: 16000

# ==============================================================================
# EXTERNAL COMPONENTS
# Local custom components for audio and discovery functionality
# ==============================================================================
external_components:
  - source:
      type: local
      path: custom_components

# Echo cancellation (disabled pending ESP-SR installation)
# esp_aec:
#   id: aec_component

# ==============================================================================
# mDNS DISCOVERY COMPONENT
# Automatically discover other intercom devices on the local network
# ==============================================================================
mdns_discovery:
  id: discovery_component
  service_type: "_udp-intercom._udp"
  scan_interval: 30s

  # Callback when a new peer is discovered
  on_peer_found:
    - logger.log:
        format: "Peer found: %s at %s"
        args: ["name.c_str()", "ip.c_str()"]
    - lambda: |-
        // Auto-select first discovered peer if no target is set
        if (id(target_peer_ip).state.empty()) {
          auto call = id(target_peer_ip).make_call();
          call.set_value(ip);
          call.perform();
          ESP_LOGI("p2p", "Auto-set target IP: %s", ip.c_str());
        }
    - lambda: id(main_display).update();

  # Callback when a peer goes offline
  on_peer_lost:
    - logger.log:
        format: "Peer lost: %s"
        args: ["name.c_str()"]
    - lambda: id(main_display).update();

# ==============================================================================
# UDP CALL SIGNALING
# Broadcast-based signaling for P2P call initiation and termination
# Protocol: Simple text-based messages over UDP broadcast (port 12350)
# ==============================================================================
udp:
  id: call_signaling
  port: 12350
  addresses:
    - 255.255.255.255    # Broadcast to all devices on subnet
  on_receive:
    then:
      - logger.log:
          format: "UDP signaling received: %d bytes"
          args: ["data.size()"]
      - lambda: |-
          std::string msg(data.begin(), data.end());
          ESP_LOGI("call", "Message: %s", msg.c_str());

          // ====== HANGUP MESSAGE ======
          // Format: HANGUP:sender_name:sender_ip
          // Received when remote peer terminates the call
          if (msg.rfind("HANGUP:", 0) == 0) {
            size_t p1 = msg.find(':', 7);
            if (p1 == std::string::npos) return;
            std::string peer_name = msg.substr(7, p1 - 7);
            std::string peer_ip = msg.substr(p1 + 1);

            ESP_LOGI("call", "HANGUP from %s (%s)", peer_name.c_str(), peer_ip.c_str());

            // Stop streaming if this hangup is from our active peer
            if (peer_ip == id(target_peer_ip).state && id(audio_component).is_streaming()) {
              ESP_LOGI("call", "Remote peer ended call, stopping stream");
              id(audio_component).stop();
            }
            return;
          }

          // ====== CALL REQUEST MESSAGE ======
          // Format: CALL:caller_name:caller_ip:target_name
          // Received when a remote peer wants to initiate a call with us
          if (msg.rfind("CALL:", 0) != 0) return;

          size_t p1 = msg.find(':', 5);
          size_t p2 = msg.find(':', p1 + 1);
          if (p1 == std::string::npos || p2 == std::string::npos) return;

          std::string caller_name = msg.substr(5, p1 - 5);
          std::string caller_ip = msg.substr(p1 + 1, p2 - p1 - 1);
          std::string target_name = msg.substr(p2 + 1);

          ESP_LOGI("call", "Incoming call from %s (%s) for %s",
                   caller_name.c_str(), caller_ip.c_str(), target_name.c_str());

          // Verify this call is intended for us
          if (target_name != "${name}") return;

          // Reject if already in a call
          if (id(audio_component).is_streaming()) {
            ESP_LOGW("call", "Already in call, ignoring incoming request");
            return;
          }

          // Only auto-answer mode responds automatically
          if (id(operating_mode).current_option() != "P2P Auto Answer") {
            ESP_LOGI("call", "Not in Auto Answer mode, ignoring");
            return;
          }

          // Accept the call: set peer IP and start streaming
          ESP_LOGI("call", "Auto-answering call from %s", caller_name.c_str());
          id(target_peer_ip).make_call().set_value(caller_ip).perform();
          id(audio_component).start();
      - lambda: id(main_display).update();

# ==============================================================================
# I2S AUDIO UDP COMPONENT
# Core audio streaming bridge: I2S hardware <-> UDP network
# Uses single I2S bus configuration for ES8311 codec
# ==============================================================================
i2s_audio_udp:
  id: audio_component

  # ES8311 uses a single I2S bus for both microphone and speaker
  # All pins share the same clock signals (LRCLK, BCLK, MCLK)
  i2s_lrclk_pin: GPIO45       # Word Select (Left/Right Clock)
  i2s_bclk_pin: GPIO9         # Bit Clock
  i2s_mclk_pin: GPIO16        # Master Clock (required by ES8311)
  i2s_din_pin: GPIO10         # Data In (from microphone/ADC)
  i2s_dout_pin: GPIO8         # Data Out (to speaker/DAC)

  sample_rate: 16000          # 16kHz for voice quality
  speaker_enable_pin: GPIO46  # Amplifier enable (active high)

  # Network configuration - values read dynamically from UI entities
  remote_ip: !lambda 'return id(target_peer_ip).state;'
  remote_port: !lambda 'return (uint16_t)id(target_peer_port).state;'
  listen_port: ${p2p_port}

  # Echo cancellation (disabled pending ESP-SR installation)
  # aec_id: aec_component

  # Callback when streaming starts
  on_start:
    - lambda: |-
        id(call_active_flag) = true;
        id(countdown_seconds) = 60;  // Reset auto-hangup timer
        ESP_LOGI("audio", "Streaming started");
    - light.turn_on:
        id: status_led
        brightness: 100%
        red: 0
        green: 1
        blue: 0
        effect: "None"
    - lambda: id(main_display).update();

  # Callback when streaming stops
  on_stop:
    - lambda: |-
        id(call_active_flag) = false;
        ESP_LOGI("audio", "Streaming stopped");
        // Send HANGUP signal to peer (only in P2P mode, not go2rtc)
        if (id(operating_mode).current_option() != "go2rtc") {
          auto ips = wifi::global_wifi_component->get_ip_addresses();
          std::string our_ip = ips.empty() ? "" : ips[0].str();
          std::string msg = "HANGUP:${name}:" + our_ip;
          id(call_message) = msg;
          ESP_LOGI("call", "Sending HANGUP signal");
        }
    - if:
        condition:
          lambda: 'return id(operating_mode).current_option() != "go2rtc";'
        then:
          - udp.write:
              id: call_signaling
              data: !lambda 'return std::vector<uint8_t>(id(call_message).begin(), id(call_message).end());'
    - light.turn_off: status_led
    - lambda: id(main_display).update();

  # Error handling callback
  on_error:
    - logger.log:
        format: "Audio error: %s"
        args: ["error.c_str()"]

# ==============================================================================
# SENSORS
# ==============================================================================
sensor:
  # WiFi signal strength for connectivity monitoring
  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_db
    update_interval: 10s
    entity_category: diagnostic

  # Audio streaming packet counters
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_component
    tx_packets:
      name: "TX Packets"
      id: tx_packets
    rx_packets:
      name: "RX Packets"
      id: rx_packets

  # Number of discovered peers on the network
  - platform: mdns_discovery
    mdns_discovery_id: discovery_component
    peer_count:
      name: "Peer Count"
      id: peer_count

# ==============================================================================
# TEXT SENSORS
# ==============================================================================
text_sensor:
  # Current audio mode (TX_ONLY, RX_ONLY, or FULL_DUPLEX)
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_component
    audio_mode:
      name: "Audio Mode"

  # List of discovered peer devices
  - platform: mdns_discovery
    mdns_discovery_id: discovery_component
    peers_list:
      name: "Discovered Peers"
      id: discovered_peers_text

  # Currently selected peer (name and IP)
  - platform: template
    name: "Current Peer"
    id: current_peer_text
    icon: "mdi:account-check"
    update_interval: 2s
    lambda: |-
      std::string target_ip = id(target_peer_ip).state;
      if (target_ip.empty()) return std::string("(none)");
      auto& peers = id(discovery_component).get_peers();
      for (const auto& peer : peers) {
        if (peer.ip == target_ip) {
          return peer.name + " (" + peer.ip + ")";
        }
      }
      return std::string("IP: ") + target_ip;

  # Current streaming state
  - platform: template
    name: "State"
    id: state_text
    update_interval: 1s
    lambda: |-
      if (id(call_active_flag)) return std::string("STREAMING");
      return std::string("IDLE");

# ==============================================================================
# BINARY SENSORS
# ==============================================================================
binary_sensor:
  # Physical doorbell button (active low with internal pull-up)
  - platform: gpio
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    id: doorbell_button
    name: "Doorbell Button"
    on_press:
      # Trigger Home Assistant event for automation
      - homeassistant.event:
          event: esphome.doorbell_ring
          data:
            device: ${name}
      - light.turn_on:
          id: status_led
          red: 1
          green: 0.6
          blue: 0
          effect: "Fast Pulse"
    on_multi_click:
      # Long press (3+ seconds) to force stop streaming
      - timing:
          - ON for at least 3s
        then:
          - i2s_audio_udp.stop:
              id: audio_component

  # Template sensor exposing call active state to Home Assistant
  - platform: template
    name: "Call Active"
    id: call_active_sensor
    lambda: return id(call_active_flag);

  # Display touch input (for extending call duration)
  - platform: gpio
    pin:
      number: GPIO12
      mode: INPUT_PULLUP
      inverted: true
    id: touch_input
    name: "Display Touch"
    on_press:
      then:
        - if:
            condition:
              lambda: return id(call_active_flag);
            then:
              - lambda: |-
                  id(countdown_seconds) = 60;
                  ESP_LOGI("touch", "Call timer reset to 60s");

# ==============================================================================
# GLOBAL VARIABLES
# ==============================================================================
globals:
  # Boot sequence completion flag
  - id: boot_complete
    type: bool
    restore_value: false
    initial_value: "false"

  # Auto-hangup countdown timer (seconds)
  - id: countdown_seconds
    type: int
    restore_value: false
    initial_value: "60"

  # Display blink animation state
  - id: blink_state
    type: bool
    restore_value: false
    initial_value: "true"

  # Call active flag (for UI and sensors)
  - id: call_active_flag
    type: bool
    restore_value: false
    initial_value: "false"

  # Temporary buffer for UDP signaling messages
  - id: call_message
    type: std::string
    restore_value: false

# ==============================================================================
# INTERVAL TIMERS
# ==============================================================================
interval:
  # Blink state toggle for display animations (500ms cycle)
  - interval: 500ms
    then:
      - lambda: id(blink_state) = !id(blink_state);

  # Auto-hangup countdown timer (1 second tick)
  - interval: 1s
    then:
      - lambda: |-
          // Only countdown in Automatic hangup mode while streaming
          if (id(call_active_flag) && id(hangup_mode).current_option() == "Automatic") {
            if (id(countdown_seconds) > 0) {
              id(countdown_seconds) -= 1;
            }
            if (id(countdown_seconds) <= 0) {
              ESP_LOGI("countdown", "Auto hangup triggered");
              id(audio_component).stop();
            }
          }

# ==============================================================================
# SWITCHES
# ==============================================================================
switch:
  # Main streaming control switch (exposed to Home Assistant)
  - platform: template
    name: "Streaming"
    id: streaming_switch
    icon: "mdi:phone"
    turn_on_action:
      # Validate target IP is set in P2P mode
      - if:
          condition:
            and:
              - lambda: 'return id(operating_mode).current_option() != "go2rtc";'
              - lambda: 'return id(target_peer_ip).state.empty();'
          then:
            - logger.log:
                level: WARN
                format: "P2P mode requires target IP to be set"
          else:
            # Send CALL signal to peer (P2P mode only)
            - if:
                condition:
                  lambda: 'return id(operating_mode).current_option() != "go2rtc";'
                then:
                  - lambda: |-
                      std::string target = id(target_peer_ip).state;
                      std::string target_name = target;
                      // Resolve IP to peer name if available
                      auto& peers = id(discovery_component).get_peers();
                      for (const auto& p : peers) {
                        if (p.ip == target) { target_name = p.name; break; }
                      }
                      auto ips = wifi::global_wifi_component->get_ip_addresses();
                      std::string our_ip = ips.empty() ? "" : ips[0].str();
                      std::string msg = "CALL:${name}:" + our_ip + ":" + target_name;
                      id(call_message) = msg;
                      ESP_LOGI("call", "Calling %s (%s)", target_name.c_str(), target.c_str());
                  - udp.write:
                      id: call_signaling
                      data: !lambda 'return std::vector<uint8_t>(id(call_message).begin(), id(call_message).end());'
            # Start audio streaming
            - i2s_audio_udp.start:
                id: audio_component
    turn_off_action:
      - i2s_audio_udp.stop:
          id: audio_component
    lambda: return id(audio_component).is_streaming();

# Echo cancellation switch (disabled pending ESP-SR installation)
#  - platform: template
#    name: "Echo Cancellation"
#    id: aec_switch;

# ==============================================================================
# SELECT ENTITIES
# ==============================================================================
select:
  # Operating mode selection
  - platform: template
    name: "Operating Mode"
    id: operating_mode
    icon: "mdi:swap-horizontal"
    optimistic: true
    restore_value: true
    options:
      - "go2rtc"           # Connect to go2rtc server on Home Assistant
      - "P2P"              # Direct peer-to-peer (manual call initiation)
      - "P2P Auto Answer"  # P2P with automatic incoming call answering
    initial_option: "P2P Auto Answer"
    on_value:
      then:
        - lambda: |-
            if (x == "go2rtc") {
              // go2rtc mode: set Home Assistant IP and go2rtc port
              id(target_peer_ip).make_call().set_value("${ha_ip}").perform();
              id(target_peer_port).make_call().set_value(${go2rtc_port}).perform();
              ESP_LOGI("mode", "go2rtc mode: IP=${ha_ip} Port=${go2rtc_port}");
            } else {
              // P2P mode: use fixed P2P port, IP from discovery or manual
              id(target_peer_port).make_call().set_value(${p2p_port}).perform();
              ESP_LOGI("mode", "P2P mode: Port=${p2p_port}");
            }
        - lambda: id(main_display).update();

  # Hangup mode selection (automatic with timer or manual only)
  - platform: template
    name: "Hangup Mode"
    id: hangup_mode
    icon: "mdi:phone-hangup"
    optimistic: true
    restore_value: true
    options:
      - "Automatic"   # Auto-hangup after countdown expires
      - "Manual"      # Manual hangup only
    initial_option: "Automatic"

# ==============================================================================
# TEXT INPUT
# ==============================================================================
text:
  # Target peer IP address (manual entry or auto-filled by discovery)
  - platform: template
    name: "Target IP"
    id: target_peer_ip
    icon: "mdi:ip-network"
    optimistic: true
    restore_value: true
    initial_value: ""
    mode: text
    min_length: 0
    max_length: 15

# ==============================================================================
# NUMBER ENTITIES
# ==============================================================================
number:
  # Target peer UDP port
  - platform: template
    name: "Target Port"
    id: target_peer_port
    min_value: 1024
    max_value: 65535
    step: 1
    initial_value: ${p2p_port}
    optimistic: true
    restore_value: true
    entity_category: diagnostic
    icon: "mdi:wan"

  # Speaker volume control (0-100%)
  - platform: template
    name: "Speaker Volume"
    id: speaker_volume
    min_value: 0
    max_value: 100
    step: 5
    initial_value: 50
    optimistic: true
    restore_value: true
    unit_of_measurement: "%"
    icon: "mdi:volume-high"
    set_action:
      - lambda: |-
          float vol;
          if (x <= 0) {
            vol = 0.0;
          } else {
            // Map 0-100% to 0.15-0.75 DAC range (ES8311 optimal range)
            vol = 0.15 + (x / 100.0) * 0.60;
          }
          id(es8311_dac).set_volume(vol);
          ESP_LOGI("volume", "Volume: %.0f%% -> DAC %.2f", x, vol);

# ==============================================================================
# BUTTONS
# ==============================================================================
button:
  # Trigger doorbell event in Home Assistant
  - platform: template
    name: "Ring Doorbell"
    icon: "mdi:bell-ring"
    on_press:
      - homeassistant.event:
          event: esphome.doorbell_ring
          data:
            device: ${name}
      - light.turn_on:
          id: status_led
          red: 1
          green: 0.6
          blue: 0
          effect: "Fast Pulse"

  # Reset auto-hangup countdown to 60 seconds
  - platform: template
    name: "Extend Call"
    icon: "mdi:timer-plus"
    on_press:
      - lambda: |-
          id(countdown_seconds) = 60;
          ESP_LOGI("countdown", "Timer reset to 60s");

  # Force immediate mDNS peer scan
  - platform: template
    name: "Refresh Peers"
    icon: "mdi:refresh"
    on_press:
      - lambda: id(discovery_component).scan_now();

  # Cycle to next discovered peer
  - platform: template
    name: "Next Peer"
    icon: "mdi:account-arrow-right"
    on_press:
      - lambda: |-
          auto& peers = id(discovery_component).get_peers();
          if (peers.empty()) {
            ESP_LOGW("peer", "No peers available");
            return;
          }
          std::string current_ip = id(target_peer_ip).state;
          int current_idx = -1;
          for (size_t i = 0; i < peers.size(); i++) {
            if (peers[i].ip == current_ip) {
              current_idx = i;
              break;
            }
          }
          int next_idx = (current_idx + 1) % peers.size();
          auto call = id(target_peer_ip).make_call();
          call.set_value(peers[next_idx].ip);
          call.perform();
          ESP_LOGI("peer", "Selected peer: %s", peers[next_idx].name.c_str());

  # Device restart button
  - platform: restart
    name: "Restart"

# ==============================================================================
# OUTPUT & LIGHTS
# ==============================================================================
output:
  # Display backlight PWM control (active low)
  - platform: ledc
    pin: GPIO42
    id: backlight_output
    inverted: true

light:
  # Display backlight (monochromatic dimmer)
  - platform: monochromatic
    id: screen_backlight
    name: "Screen Backlight"
    output: backlight_output
    restore_mode: ALWAYS_ON
    default_transition_length: 250ms

  # WS2812 RGB status LED
  - platform: esp32_rmt_led_strip
    id: status_led
    name: "Status LED"
    pin: GPIO48
    chipset: WS2812
    num_leds: 1
    rgb_order: grb
    effects:
      - pulse:
          name: "Fast Pulse"
          transition_length: 0.3s
          update_interval: 0.3s
          min_brightness: 0%
          max_brightness: 100%

# ==============================================================================
# FONTS
# ==============================================================================
font:
  - file:
      type: gfonts
      family: Roboto
      weight: 700
    id: font_title
    size: 24
  - file:
      type: gfonts
      family: Roboto
      weight: 500
    id: font_state
    size: 32
  - file:
      type: gfonts
      family: Roboto Mono
      weight: 400
    id: font_debug
    size: 14

# ==============================================================================
# COLORS
# ==============================================================================
color:
  - id: color_idle
    hex: "2196F3"           # Blue - idle state background
  - id: color_streaming
    hex: "4CAF50"           # Green - streaming state background
  - id: color_white
    hex: "FFFFFF"           # White - text and UI elements
  - id: color_text_idle
    hex: "00FF00"           # Bright green - idle state text
  - id: color_text_streaming
    hex: "FF0000"           # Red - streaming state text

# ==============================================================================
# DISPLAY (GC9A01A 240x240 Round LCD)
# ==============================================================================
spi:
  - id: spi_bus
    clk_pin: GPIO4
    mosi_pin: GPIO2

display:
  - platform: ili9xxx
    id: main_display
    model: GC9A01A
    invert_colors: true
    data_rate: 40MHz
    cs_pin: GPIO5
    dc_pin: GPIO47
    reset_pin: GPIO38
    update_interval: 250ms
    dimensions:
      height: 240
      width: 240
    lambda: |-
      const int w = it.get_width();
      const int h = it.get_height();
      const int cx = w / 2;
      const int cy = h / 2;

      bool streaming = id(call_active_flag);

      // Select colors based on current state
      Color bg_color = streaming ? id(color_streaming) : id(color_idle);
      Color text_color = streaming ? id(color_text_streaming) : id(color_text_idle);
      const char* state_text = streaming ? "STREAMING" : "IDLE";

      // Fill background
      it.fill(bg_color);

      // Title at top
      it.print(cx, 30, id(font_title), id(color_white), TextAlign::CENTER, "INTERCOM");

      // State indicator in center
      it.print(cx, cy, id(font_state), text_color, TextAlign::CENTER, state_text);

      // Auto-hangup countdown (only shown in Automatic mode while streaming)
      if (streaming && id(hangup_mode).current_option() == "Automatic") {
        char countdown_buf[16];
        int secs = id(countdown_seconds);
        snprintf(countdown_buf, sizeof(countdown_buf), "Auto: %02d:%02d", secs / 60, secs % 60);
        it.print(cx, cy + 35, id(font_debug), id(color_white), TextAlign::CENTER, countdown_buf);
      }

      // Packet statistics
      char buf[32];
      snprintf(buf, sizeof(buf), "TX:%lu RX:%lu",
               (unsigned long)id(audio_component).get_tx_packets(),
               (unsigned long)id(audio_component).get_rx_packets());
      it.print(cx, h - 55, id(font_debug), id(color_white), TextAlign::CENTER, buf);

      // WiFi signal strength percentage
      float wifi_pct = 0;
      if (id(wifi_signal_db).has_state()) {
        float dbm = id(wifi_signal_db).state;
        if (dbm >= -50) wifi_pct = 100;
        else if (dbm <= -100) wifi_pct = 0;
        else wifi_pct = 2 * (dbm + 100);
      }
      snprintf(buf, sizeof(buf), "WiFi: %.0f%%", wifi_pct);
      it.print(cx, h - 35, id(font_debug), id(color_white), TextAlign::CENTER, buf);

      // Home Assistant API connection status
      const char* api_status = id(api_server).is_connected() ? "HA: OK" : "HA: DISC";
      it.print(cx, h - 15, id(font_debug), id(color_white), TextAlign::CENTER, api_status);
