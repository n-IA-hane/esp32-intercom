# =============================================================================
# ESP32-S3 UDP INTERCOM - Xiaozhi Ball V3 (ES8311 + GC9A01A Display)
# =============================================================================
# Hardware: Xiaozhi Ball V3 (ESP32-S3 + ES8311 codec + GC9A01A display)
# Uses: i2s_audio_udp + mdns_discovery + esp_aec components
#
# Created by Claude (Anthropic) for n-IA-hane
# https://github.com/n-IA-hane/esp32-intercom
# =============================================================================

substitutions:
  name: intercom
  friendly_name: Intercom
  ha_ip: "192.168.1.10"
  go2rtc_port: "12345"
  p2p_port: "12346"

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.5.0
  name_add_mac_suffix: false
  on_boot:
    priority: 600
    then:
      - lambda: id(boot_complete) = false;
      - delay: 3s
      - lambda: id(boot_complete) = true;
      - lambda: |-
          // Apply saved volume on boot
          float x = id(speaker_volume).state;
          float vol;
          if (x <= 0) {
            vol = 0.0;
          } else {
            vol = 0.15 + (x / 100.0) * 0.60;
          }
          id(es8311_dac).set_volume(vol);
          ESP_LOGI("boot", "Applied saved volume: %.0f%% -> DAC %.2f", x, vol);
      - component.update: main_display

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 16MB
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
    # AEC disabled - ESP-SR requires different installation approach
    # components:
    #   - espressif/esp-sr^2.3.0

psram:
  mode: octal
  speed: 80MHz

# =============================================================================
# CONNECTIVITY
# =============================================================================
api:
  id: api_server

ota:
  - platform: esphome

web_server:
  port: 80

logger:
  hardware_uart: USB_SERIAL_JTAG
  level: DEBUG

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Intercom Fallback"

# =============================================================================
# mDNS SERVICE FOR P2P DISCOVERY
# =============================================================================
mdns:
  services:
    - service: "_udp-intercom"
      protocol: "_udp"
      port: 12346
      txt:
        device: ${name}
        type: "intercom"

# =============================================================================
# I2C FOR ES8311 CODEC CONTROL
# =============================================================================
i2c:
  sda: GPIO15
  scl: GPIO14
  scan: true
  id: bus_a

audio_dac:
  - platform: es8311
    id: es8311_dac
    bits_per_sample: 16bit
    sample_rate: 16000

# =============================================================================
# EXTERNAL COMPONENTS (REFACTORED ARCHITECTURE)
# =============================================================================
external_components:
  - source:
      type: local
      path: custom_components

# AEC disabled for now - ESP-SR installation issue
# esp_aec:
#   id: aec_component

# =============================================================================
# mDNS DISCOVERY - For P2P peer finding
# =============================================================================
mdns_discovery:
  id: discovery_component
  service_type: "_udp-intercom._udp"
  scan_interval: 30s
  on_peer_found:
    - logger.log:
        format: "Peer found: %s at %s"
        args: ["name.c_str()", "ip.c_str()"]
    - lambda: |-
        if (id(target_peer_ip).state.empty()) {
          auto call = id(target_peer_ip).make_call();
          call.set_value(ip);
          call.perform();
          ESP_LOGI("p2p", "Auto-set target IP: %s", ip.c_str());
        }
    - lambda: id(main_display).update();
  on_peer_lost:
    - logger.log:
        format: "Peer lost: %s"
        args: ["name.c_str()"]
    - lambda: id(main_display).update();

# =============================================================================
# UDP CALL SIGNALING - Broadcast per avvio chiamate P2P
# =============================================================================
udp:
  id: call_signaling
  port: 12350
  addresses:
    - 255.255.255.255
  on_receive:
    then:
      # Log raw per debug
      - logger.log:
          format: "UDP ricevuto: %d bytes"
          args: ["data.size()"]
      - lambda: |-
          std::string msg(data.begin(), data.end());
          ESP_LOGI("call", "Messaggio: %s", msg.c_str());

          // === HANGUP:nome:ip ===
          if (msg.rfind("HANGUP:", 0) == 0) {
            size_t p1 = msg.find(':', 7);
            if (p1 == std::string::npos) return;
            std::string peer_name = msg.substr(7, p1 - 7);
            std::string peer_ip = msg.substr(p1 + 1);

            ESP_LOGI("call", "HANGUP da %s (%s)", peer_name.c_str(), peer_ip.c_str());

            // Se l'IP corrisponde al nostro peer attuale e stiamo streamando
            if (peer_ip == id(target_peer_ip).state && id(audio_component).is_streaming()) {
              ESP_LOGI("call", "Peer ha chiuso, termino chiamata");
              id(audio_component).stop();
            }
            return;
          }

          // === CALL:nome:ip:target ===
          if (msg.rfind("CALL:", 0) != 0) return;

          size_t p1 = msg.find(':', 5);
          size_t p2 = msg.find(':', p1 + 1);
          if (p1 == std::string::npos || p2 == std::string::npos) return;

          std::string caller_name = msg.substr(5, p1 - 5);
          std::string caller_ip = msg.substr(p1 + 1, p2 - p1 - 1);
          std::string target_name = msg.substr(p2 + 1);

          ESP_LOGI("call", "Richiesta da %s (%s) per %s",
                   caller_name.c_str(), caller_ip.c_str(), target_name.c_str());

          // Sono io il target?
          if (target_name != "${name}") return;

          // Gia in chiamata?
          if (id(audio_component).is_streaming()) {
            ESP_LOGW("call", "Gia in chiamata, ignoro");
            return;
          }

          // Solo Auto Answer risponde automaticamente
          if (id(operating_mode).state != "P2P Auto Answer") {
            ESP_LOGI("call", "Non in Auto Answer, ignoro");
            return;
          }

          ESP_LOGI("call", "Auto-answer: rispondo a %s", caller_name.c_str());
          id(target_peer_ip).make_call().set_value(caller_ip).perform();
          id(audio_component).start();
      - lambda: id(main_display).update();

# =============================================================================
# I2S AUDIO UDP - Core audio bridge (ES8311 single bus)
# =============================================================================
i2s_audio_udp:
  id: audio_component

  # Single bus pins (ES8311 codec)
  i2s_lrclk_pin: GPIO45
  i2s_bclk_pin: GPIO9
  i2s_mclk_pin: GPIO16
  i2s_din_pin: GPIO10
  i2s_dout_pin: GPIO8

  sample_rate: 16000
  speaker_enable_pin: GPIO46

  # Network - valori letti dalle entitÃ  (gestite dal select on_value)
  remote_ip: !lambda 'return id(target_peer_ip).state;'
  remote_port: !lambda 'return (uint16_t)id(target_peer_port).state;'
  listen_port: ${p2p_port}

  # AEC integration disabled
  # aec_id: aec_component

  on_start:
    - lambda: |-
        id(call_active_flag) = true;
        id(countdown_seconds) = 60;
        ESP_LOGI("audio", "Streaming started");
    - light.turn_on:
        id: status_led
        brightness: 100%
        red: 0
        green: 1
        blue: 0
        effect: "None"
    - lambda: id(main_display).update();

  on_stop:
    - lambda: |-
        id(call_active_flag) = false;
        ESP_LOGI("audio", "Streaming stopped");
        // Invia HANGUP solo se in P2P mode
        if (id(operating_mode).state != "go2rtc") {
          auto ips = wifi::global_wifi_component->get_ip_addresses();
          std::string our_ip = ips.empty() ? "" : ips[0].str();
          std::string msg = "HANGUP:${name}:" + our_ip;
          id(call_message) = msg;
          ESP_LOGI("call", "Invio HANGUP");
        }
    - if:
        condition:
          lambda: 'return id(operating_mode).state != "go2rtc";'
        then:
          - udp.write:
              id: call_signaling
              data: !lambda 'return std::vector<uint8_t>(id(call_message).begin(), id(call_message).end());'
    - light.turn_off: status_led
    - lambda: id(main_display).update();

  on_error:
    - logger.log:
        format: "Audio error: %s"
        args: ["error.c_str()"]

# =============================================================================
# SENSORS
# =============================================================================
sensor:
  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_db
    update_interval: 10s
    entity_category: diagnostic

  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_component
    tx_packets:
      name: "TX Packets"
      id: tx_packets
    rx_packets:
      name: "RX Packets"
      id: rx_packets

  - platform: mdns_discovery
    mdns_discovery_id: discovery_component
    peer_count:
      name: "Peer Count"
      id: peer_count

text_sensor:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_component
    audio_mode:
      name: "Audio Mode"

  - platform: mdns_discovery
    mdns_discovery_id: discovery_component
    peers_list:
      name: "Discovered Peers"
      id: discovered_peers_text

  - platform: template
    name: "Current Peer"
    id: current_peer_text
    icon: "mdi:account-check"
    update_interval: 2s
    lambda: |-
      std::string target_ip = id(target_peer_ip).state;
      if (target_ip.empty()) return std::string("(nessuno)");
      auto& peers = id(discovery_component).get_peers();
      for (const auto& peer : peers) {
        if (peer.ip == target_ip) {
          return peer.name + " (" + peer.ip + ")";
        }
      }
      return std::string("IP: ") + target_ip;

  - platform: template
    name: "State"
    id: state_text
    update_interval: 1s
    lambda: |-
      if (id(call_active_flag)) return std::string("STREAMING");
      return std::string("IDLE");

# =============================================================================
# BINARY SENSORS
# =============================================================================
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO0
      mode: INPUT_PULLUP
      inverted: true
    id: doorbell_button
    name: "Doorbell Button"
    on_press:
      - homeassistant.event:
          event: esphome.doorbell_ring
          data:
            device: ${name}
      - light.turn_on:
          id: status_led
          red: 1
          green: 0.6
          blue: 0
          effect: "Fast Pulse"
    on_multi_click:
      - timing:
          - ON for at least 3s
        then:
          - i2s_audio_udp.stop:
              id: audio_component

  - platform: template
    name: "Call Active"
    id: call_active_sensor
    lambda: return id(call_active_flag);

  - platform: gpio
    pin:
      number: GPIO12
      mode: INPUT_PULLUP
      inverted: true
    id: touch_input
    name: "Display Touch"
    on_press:
      then:
        - if:
            condition:
              lambda: return id(call_active_flag);
            then:
              - lambda: |-
                  id(countdown_seconds) = 60;
                  ESP_LOGI("touch", "Countdown reset");

# =============================================================================
# GLOBALS
# =============================================================================
globals:
  - id: boot_complete
    type: bool
    restore_value: false
    initial_value: "false"
  - id: countdown_seconds
    type: int
    restore_value: false
    initial_value: "60"
  - id: blink_state
    type: bool
    restore_value: false
    initial_value: "true"
  - id: call_active_flag
    type: bool
    restore_value: false
    initial_value: "false"
  - id: call_message
    type: std::string
    restore_value: false

# =============================================================================
# INTERVAL FOR COUNTDOWN
# =============================================================================
interval:
  - interval: 500ms
    then:
      - lambda: id(blink_state) = !id(blink_state);
  - interval: 1s
    then:
      - lambda: |-
          if (id(call_active_flag) && id(hangup_mode).state == "Automatic") {
            if (id(countdown_seconds) > 0) {
              id(countdown_seconds) -= 1;
            }
            if (id(countdown_seconds) <= 0) {
              ESP_LOGI("countdown", "Auto hangup!");
              id(audio_component).stop();
            }
          }

# =============================================================================
# SWITCHES
# =============================================================================
switch:
  - platform: template
    name: "Streaming"
    id: streaming_switch
    icon: "mdi:phone"
    turn_on_action:
      # Verifica target IP in P2P mode
      - if:
          condition:
            and:
              - lambda: 'return id(operating_mode).state != "go2rtc";'
              - lambda: 'return id(target_peer_ip).state.empty();'
          then:
            - logger.log:
                level: WARN
                format: "P2P mode but no target IP!"
          else:
            # Invia CALL signal se in P2P mode
            - if:
                condition:
                  lambda: 'return id(operating_mode).state != "go2rtc";'
                then:
                  - lambda: |-
                      std::string target = id(target_peer_ip).state;
                      std::string target_name = target;
                      auto& peers = id(discovery_component).get_peers();
                      for (const auto& p : peers) {
                        if (p.ip == target) { target_name = p.name; break; }
                      }
                      auto ips = wifi::global_wifi_component->get_ip_addresses();
                      std::string our_ip = ips.empty() ? "" : ips[0].str();
                      std::string msg = "CALL:${name}:" + our_ip + ":" + target_name;
                      id(call_message) = msg;
                      ESP_LOGI("call", "Chiamo %s (%s)", target_name.c_str(), target.c_str());
                  - udp.write:
                      id: call_signaling
                      data: !lambda 'return std::vector<uint8_t>(id(call_message).begin(), id(call_message).end());'
            # Avvia streaming
            - i2s_audio_udp.start:
                id: audio_component
    turn_off_action:
      - i2s_audio_udp.stop:
          id: audio_component
    lambda: return id(audio_component).is_streaming();

# AEC switch disabled - ESP-SR installation issue
#  - platform: template
#    name: "Echo Cancellation"
#    id: aec_switch;

# =============================================================================
# SELECT FOR OPERATING MODE
# =============================================================================
select:
  - platform: template
    name: "Operating Mode"
    id: operating_mode
    icon: "mdi:swap-horizontal"
    optimistic: true
    restore_value: true
    options:
      - "go2rtc"
      - "P2P"
      - "P2P Auto Answer"
    initial_option: "P2P Auto Answer"
    on_value:
      then:
        - lambda: |-
            if (x == "go2rtc") {
              // go2rtc mode: imposta IP e porta del server
              id(target_peer_ip).make_call().set_value("${ha_ip}").perform();
              id(target_peer_port).make_call().set_value(${go2rtc_port}).perform();
              ESP_LOGI("mode", "go2rtc: IP=${ha_ip} Port=${go2rtc_port}");
            } else {
              // P2P mode: porta fissa, IP da discovery o manuale
              id(target_peer_port).make_call().set_value(${p2p_port}).perform();
              ESP_LOGI("mode", "P2P: Port=${p2p_port}");
            }
        - lambda: id(main_display).update();

  - platform: template
    name: "Hangup Mode"
    id: hangup_mode
    icon: "mdi:phone-hangup"
    optimistic: true
    restore_value: true
    options:
      - "Automatic"
      - "Manual"
    initial_option: "Automatic"

# =============================================================================
# TEXT INPUT FOR TARGET IP
# =============================================================================
text:
  - platform: template
    name: "Target IP"
    id: target_peer_ip
    icon: "mdi:ip-network"
    optimistic: true
    restore_value: true
    initial_value: ""
    mode: text
    min_length: 0
    max_length: 15

# =============================================================================
# SPEAKER VOLUME CONTROL & TARGET PORT
# =============================================================================
number:
  - platform: template
    name: "Target Port"
    id: target_peer_port
    min_value: 1024
    max_value: 65535
    step: 1
    initial_value: ${p2p_port}
    optimistic: true
    restore_value: true
    entity_category: diagnostic
    icon: "mdi:wan"

  - platform: template
    name: "Speaker Volume"
    id: speaker_volume
    min_value: 0
    max_value: 100
    step: 5
    initial_value: 50
    optimistic: true
    restore_value: true
    unit_of_measurement: "%"
    icon: "mdi:volume-high"
    set_action:
      - lambda: |-
          float vol;
          if (x <= 0) {
            vol = 0.0;
          } else {
            vol = 0.15 + (x / 100.0) * 0.60;
          }
          id(es8311_dac).set_volume(vol);
          ESP_LOGI("volume", "Volume: %.0f%% -> DAC %.2f", x, vol);

# =============================================================================
# BUTTONS
# =============================================================================
button:
  - platform: template
    name: "Ring Doorbell"
    icon: "mdi:bell-ring"
    on_press:
      - homeassistant.event:
          event: esphome.doorbell_ring
          data:
            device: ${name}
      - light.turn_on:
          id: status_led
          red: 1
          green: 0.6
          blue: 0
          effect: "Fast Pulse"

  - platform: template
    name: "Extend Call"
    icon: "mdi:timer-plus"
    on_press:
      - lambda: |-
          id(countdown_seconds) = 60;
          ESP_LOGI("countdown", "Reset to 60s");

  - platform: template
    name: "Refresh Peers"
    icon: "mdi:refresh"
    on_press:
      - lambda: id(discovery_component).scan_now();

  - platform: template
    name: "Next Peer"
    icon: "mdi:account-arrow-right"
    on_press:
      - lambda: |-
          auto& peers = id(discovery_component).get_peers();
          if (peers.empty()) {
            ESP_LOGW("peer", "No peers");
            return;
          }
          std::string current_ip = id(target_peer_ip).state;
          int current_idx = -1;
          for (size_t i = 0; i < peers.size(); i++) {
            if (peers[i].ip == current_ip) {
              current_idx = i;
              break;
            }
          }
          int next_idx = (current_idx + 1) % peers.size();
          auto call = id(target_peer_ip).make_call();
          call.set_value(peers[next_idx].ip);
          call.perform();
          ESP_LOGI("peer", "Selected: %s", peers[next_idx].name.c_str());

  - platform: restart
    name: "Restart"

# =============================================================================
# OUTPUT & LIGHTS
# =============================================================================
output:
  - platform: ledc
    pin: GPIO42
    id: backlight_output
    inverted: true

light:
  - platform: monochromatic
    id: screen_backlight
    name: "Screen Backlight"
    output: backlight_output
    restore_mode: ALWAYS_ON
    default_transition_length: 250ms

  - platform: esp32_rmt_led_strip
    id: status_led
    name: "Status LED"
    pin: GPIO48
    chipset: WS2812
    num_leds: 1
    rgb_order: grb
    effects:
      - pulse:
          name: "Fast Pulse"
          transition_length: 0.3s
          update_interval: 0.3s
          min_brightness: 0%
          max_brightness: 100%

# =============================================================================
# FONTS
# =============================================================================
font:
  - file:
      type: gfonts
      family: Roboto
      weight: 700
    id: font_title
    size: 24
  - file:
      type: gfonts
      family: Roboto
      weight: 500
    id: font_state
    size: 32
  - file:
      type: gfonts
      family: Roboto Mono
      weight: 400
    id: font_debug
    size: 14

# =============================================================================
# COLORS
# =============================================================================
color:
  - id: color_idle
    hex: "2196F3"
  - id: color_streaming
    hex: "4CAF50"
  - id: color_white
    hex: "FFFFFF"
  - id: color_text_idle
    hex: "00FF00"
  - id: color_text_streaming
    hex: "FF0000"

# =============================================================================
# DISPLAY (GC9A01A 240x240 round)
# =============================================================================
spi:
  - id: spi_bus
    clk_pin: GPIO4
    mosi_pin: GPIO2

display:
  - platform: ili9xxx
    id: main_display
    model: GC9A01A
    invert_colors: true
    data_rate: 40MHz
    cs_pin: GPIO5
    dc_pin: GPIO47
    reset_pin: GPIO38
    update_interval: 250ms
    dimensions:
      height: 240
      width: 240
    lambda: |-
      const int w = it.get_width();
      const int h = it.get_height();
      const int cx = w / 2;
      const int cy = h / 2;

      bool streaming = id(call_active_flag);

      Color bg_color = streaming ? id(color_streaming) : id(color_idle);
      Color text_color = streaming ? id(color_text_streaming) : id(color_text_idle);
      const char* state_text = streaming ? "STREAMING" : "IDLE";

      it.fill(bg_color);

      // Title
      it.print(cx, 30, id(font_title), id(color_white), TextAlign::CENTER, "INTERCOM");

      // State text
      it.print(cx, cy, id(font_state), text_color, TextAlign::CENTER, state_text);

      // Countdown when streaming
      if (streaming && id(hangup_mode).state == "Automatic") {
        char countdown_buf[16];
        int secs = id(countdown_seconds);
        snprintf(countdown_buf, sizeof(countdown_buf), "Auto: %02d:%02d", secs / 60, secs % 60);
        it.print(cx, cy + 35, id(font_debug), id(color_white), TextAlign::CENTER, countdown_buf);
      }

      // Debug info
      char buf[32];
      snprintf(buf, sizeof(buf), "TX:%lu RX:%lu",
               (unsigned long)id(audio_component).get_tx_packets(),
               (unsigned long)id(audio_component).get_rx_packets());
      it.print(cx, h - 55, id(font_debug), id(color_white), TextAlign::CENTER, buf);

      // WiFi signal
      float wifi_pct = 0;
      if (id(wifi_signal_db).has_state()) {
        float dbm = id(wifi_signal_db).state;
        if (dbm >= -50) wifi_pct = 100;
        else if (dbm <= -100) wifi_pct = 0;
        else wifi_pct = 2 * (dbm + 100);
      }
      snprintf(buf, sizeof(buf), "WiFi: %.0f%%", wifi_pct);
      it.print(cx, h - 35, id(font_debug), id(color_white), TextAlign::CENTER, buf);

      // API status
      const char* api_status = id(api_server).is_connected() ? "HA: OK" : "HA: DISC";
      it.print(cx, h - 15, id(font_debug), id(color_white), TextAlign::CENTER, api_status);
