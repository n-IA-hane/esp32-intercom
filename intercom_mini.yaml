# =============================================================================
# ESP32-S3 MINI INTERCOM - Refactored Components
# =============================================================================
# Hardware: ESP32-S3 Mini + INMP441 Mic + MAX98357A Amplifier
# Features: P2P mode with auto-answer, software volume control
# Uses: i2s_audio_udp + mdns_discovery components
#
# Created by Claude (Anthropic) for n-IA-hane
# https://github.com/n-IA-hane/esp32-intercom
# =============================================================================

substitutions:
  name: intercom-mini
  friendly_name: Intercom Mini
  ha_ip: "192.168.1.10"
  go2rtc_port: "12347"
  p2p_port: "12346"

esphome:
  name: ${name}
  friendly_name: ${friendly_name}
  min_version: 2025.5.0
  name_add_mac_suffix: false
  platformio_options:
    board_build.flash_mode: dio
  on_boot:
    priority: -100
    then:
      - lambda: |-
          // Apply saved volume
          id(audio_component).set_volume(id(speaker_volume).state / 100.0);
          ESP_LOGI("boot", "Volume: %.0f%%", id(speaker_volume).state);

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"

psram:
  mode: quad
  speed: 80MHz

# =============================================================================
# CONNECTIVITY
# =============================================================================
api:
  id: api_server

ota:
  - platform: esphome

web_server:
  port: 80

logger:
  hardware_uart: UART0
  level: DEBUG

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: "Intercom-Mini Fallback"

# =============================================================================
# mDNS SERVICE FOR P2P DISCOVERY
# =============================================================================
mdns:
  services:
    - service: "_udp-intercom"
      protocol: "_udp"
      port: 12346
      txt:
        device: ${name}
        type: "intercom"

# =============================================================================
# EXTERNAL COMPONENTS (REFACTORED ARCHITECTURE)
# =============================================================================
external_components:
  - source:
      type: local
      path: custom_components

# =============================================================================
# mDNS DISCOVERY - For P2P peer finding
# =============================================================================
mdns_discovery:
  id: discovery_component
  service_type: "_udp-intercom._udp"
  scan_interval: 30s
  on_peer_found:
    - logger.log:
        format: "Peer found: %s at %s"
        args: ["name.c_str()", "ip.c_str()"]
    - lambda: |-
        if (id(target_peer_ip).state.empty()) {
          auto call = id(target_peer_ip).make_call();
          call.set_value(ip);
          call.perform();
          ESP_LOGI("p2p", "Auto-set target IP: %s", ip.c_str());
        }
  on_peer_lost:
    - logger.log:
        format: "Peer lost: %s"
        args: ["name.c_str()"]
    - lambda: |-
        std::string current = id(target_peer_ip).state;
        auto& peers = id(discovery_component).get_peers();
        bool found = false;
        for (const auto& p : peers) {
          if (p.ip == current) { found = true; break; }
        }
        if (!found && !peers.empty()) {
          auto call = id(target_peer_ip).make_call();
          call.set_value(peers[0].ip);
          call.perform();
        }

# =============================================================================
# UDP CALL SIGNALING - Per avvio chiamate P2P
# =============================================================================
udp:
  id: call_signaling
  port: 12350
  addresses:
    - 255.255.255.255
  on_receive:
    then:
      # Log raw per debug
      - logger.log:
          format: "UDP ricevuto: %d bytes"
          args: ["data.size()"]
      - lambda: |-
          std::string msg(data.begin(), data.end());
          ESP_LOGI("call", "Messaggio: %s", msg.c_str());

          // === HANGUP:nome:ip ===
          if (msg.rfind("HANGUP:", 0) == 0) {
            size_t p1 = msg.find(':', 7);
            if (p1 == std::string::npos) return;
            std::string peer_name = msg.substr(7, p1 - 7);
            std::string peer_ip = msg.substr(p1 + 1);

            ESP_LOGI("call", "HANGUP da %s (%s)", peer_name.c_str(), peer_ip.c_str());

            // Se l'IP corrisponde al nostro peer attuale e stiamo streamando
            if (peer_ip == id(target_peer_ip).state && id(audio_component).is_streaming()) {
              ESP_LOGI("call", "Peer ha chiuso, termino chiamata");
              id(audio_component).stop();
            }
            return;
          }

          // === CALL:nome:ip:target ===
          if (msg.rfind("CALL:", 0) != 0) return;

          size_t p1 = msg.find(':', 5);
          size_t p2 = msg.find(':', p1 + 1);
          if (p1 == std::string::npos || p2 == std::string::npos) return;

          std::string caller_name = msg.substr(5, p1 - 5);
          std::string caller_ip = msg.substr(p1 + 1, p2 - p1 - 1);
          std::string target_name = msg.substr(p2 + 1);

          ESP_LOGI("call", "Richiesta da %s (%s) per %s",
                   caller_name.c_str(), caller_ip.c_str(), target_name.c_str());

          // Sono io il target?
          if (target_name != "${name}") return;

          // Gia in chiamata?
          if (id(audio_component).is_streaming()) {
            ESP_LOGW("call", "Gia in chiamata, ignoro");
            return;
          }

          // Solo Auto Answer risponde automaticamente
          if (id(operating_mode).state != "P2P Auto Answer") {
            ESP_LOGI("call", "Non in Auto Answer, ignoro");
            return;
          }

          ESP_LOGI("call", "Auto-answer: rispondo a %s", caller_name.c_str());
          id(target_peer_ip).make_call().set_value(caller_ip).perform();
          id(audio_component).start();

# =============================================================================
# I2S AUDIO UDP - Core audio bridge (INMP441 + MAX98357A dual bus)
# =============================================================================
i2s_audio_udp:
  id: audio_component

  # Microphone (INMP441) - I2S_NUM_0
  mic_lrclk_pin: GPIO3
  mic_bclk_pin: GPIO2
  mic_din_pin: GPIO4

  # Speaker (MAX98357A) - I2S_NUM_1
  speaker_lrclk_pin: GPIO6
  speaker_bclk_pin: GPIO7
  speaker_dout_pin: GPIO8

  sample_rate: 16000

  # INMP441 specific settings
  mic_bits_per_sample: 32
  mic_channel: left
  mic_gain: 4

  # Network - valori letti dalle entitÃ  (gestite dal select on_value)
  remote_ip: !lambda 'return id(target_peer_ip).state;'
  remote_port: !lambda 'return (uint16_t)id(target_peer_port).state;'
  listen_port: ${p2p_port}

  on_start:
    - lambda: |-
        id(call_active_flag) = true;
        ESP_LOGI("audio", "Streaming started");
    - light.turn_on:
        id: status_led
        brightness: 100%
        red: 0
        green: 1
        blue: 0
        effect: "None"

  on_stop:
    - lambda: |-
        id(call_active_flag) = false;
        ESP_LOGI("audio", "Streaming stopped");
        // Invia HANGUP solo se in P2P mode
        if (id(operating_mode).state != "go2rtc") {
          auto ips = wifi::global_wifi_component->get_ip_addresses();
          std::string our_ip = ips.empty() ? "" : ips[0].str();
          std::string msg = "HANGUP:${name}:" + our_ip;
          id(call_message) = msg;
          ESP_LOGI("call", "Invio HANGUP");
        }
    - if:
        condition:
          lambda: 'return id(operating_mode).state != "go2rtc";'
        then:
          - udp.write:
              id: call_signaling
              data: !lambda 'return std::vector<uint8_t>(id(call_message).begin(), id(call_message).end());'
    - light.turn_off: status_led

  on_error:
    - logger.log:
        format: "Audio error: %s"
        args: ["error.c_str()"]
    - light.turn_on:
        id: status_led
        red: 1
        green: 0
        blue: 0

# =============================================================================
# SENSORS
# =============================================================================
sensor:
  - platform: wifi_signal
    name: "WiFi Signal"
    id: wifi_signal_db
    update_interval: 30s
    entity_category: diagnostic

  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_component
    tx_packets:
      name: "TX Packets"
      id: tx_packets
    rx_packets:
      name: "RX Packets"
      id: rx_packets

  - platform: mdns_discovery
    mdns_discovery_id: discovery_component
    peer_count:
      name: "Peer Count"
      id: peer_count

text_sensor:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_component
    audio_mode:
      name: "Audio Mode"

  - platform: mdns_discovery
    mdns_discovery_id: discovery_component
    peers_list:
      name: "Discovered Peers"
      id: discovered_peers_text
      entity_category: diagnostic

  - platform: template
    name: "Current Peer"
    id: current_peer_text
    icon: "mdi:account-check"
    update_interval: 2s
    lambda: |-
      std::string target_ip = id(target_peer_ip).state;
      if (target_ip.empty()) return std::string("(nessuno)");
      auto& peers = id(discovery_component).get_peers();
      for (const auto& peer : peers) {
        if (peer.ip == target_ip) {
          return peer.name + " (" + peer.ip + ")";
        }
      }
      return std::string("IP: ") + target_ip;

  - platform: template
    name: "State"
    id: state_text
    update_interval: 1s
    lambda: |-
      if (id(call_active_flag)) return std::string("STREAMING");
      return std::string("IDLE");

# =============================================================================
# BINARY SENSORS
# =============================================================================
binary_sensor:
  - platform: template
    name: "Call Active"
    id: call_active_sensor
    lambda: return id(call_active_flag);

# =============================================================================
# GLOBALS
# =============================================================================
globals:
  - id: call_active_flag
    type: bool
    restore_value: false
    initial_value: "false"
  - id: call_message
    type: std::string
    restore_value: false

# =============================================================================
# SELECT FOR OPERATING MODE
# =============================================================================
select:
  - platform: template
    name: "Operating Mode"
    id: operating_mode
    icon: "mdi:swap-horizontal"
    optimistic: true
    restore_value: true
    options:
      - "go2rtc"
      - "P2P"
      - "P2P Auto Answer"
    initial_option: "P2P Auto Answer"
    on_value:
      then:
        - lambda: |-
            if (x == "go2rtc") {
              // go2rtc mode: imposta IP e porta del server
              id(target_peer_ip).make_call().set_value("${ha_ip}").perform();
              id(target_peer_port).make_call().set_value(${go2rtc_port}).perform();
              ESP_LOGI("mode", "go2rtc: IP=${ha_ip} Port=${go2rtc_port}");
            } else {
              // P2P mode: porta fissa, IP da discovery o manuale
              id(target_peer_port).make_call().set_value(${p2p_port}).perform();
              ESP_LOGI("mode", "P2P: Port=${p2p_port}");
            }

# =============================================================================
# TEXT INPUT FOR TARGET IP
# =============================================================================
text:
  - platform: template
    name: "Target IP"
    id: target_peer_ip
    icon: "mdi:ip-network"
    optimistic: true
    restore_value: true
    initial_value: ""
    mode: text
    min_length: 0
    max_length: 15

# =============================================================================
# SWITCHES
# =============================================================================
switch:
  - platform: template
    name: "Streaming"
    id: streaming_switch
    icon: "mdi:phone"
    turn_on_action:
      # Verifica target IP in P2P mode
      - if:
          condition:
            and:
              - lambda: 'return id(operating_mode).state != "go2rtc";'
              - lambda: 'return id(target_peer_ip).state.empty();'
          then:
            - logger.log:
                level: WARN
                format: "P2P mode but no target IP!"
          else:
            # Invia CALL signal se in P2P mode
            - if:
                condition:
                  lambda: 'return id(operating_mode).state != "go2rtc";'
                then:
                  - lambda: |-
                      std::string target = id(target_peer_ip).state;
                      std::string target_name = target;
                      auto& peers = id(discovery_component).get_peers();
                      for (const auto& p : peers) {
                        if (p.ip == target) { target_name = p.name; break; }
                      }
                      auto ips = wifi::global_wifi_component->get_ip_addresses();
                      std::string our_ip = ips.empty() ? "" : ips[0].str();
                      std::string msg = "CALL:${name}:" + our_ip + ":" + target_name;
                      // Salva in global per udp.write
                      id(call_message) = msg;
                      ESP_LOGI("call", "Chiamo %s (%s)", target_name.c_str(), target.c_str());
                  - udp.write:
                      id: call_signaling
                      data: !lambda 'return std::vector<uint8_t>(id(call_message).begin(), id(call_message).end());'
            # Avvia streaming
            - i2s_audio_udp.start:
                id: audio_component
    turn_off_action:
      - i2s_audio_udp.stop:
          id: audio_component
    lambda: return id(audio_component).is_streaming();

# =============================================================================
# VOLUME CONTROL & TARGET PORT
# =============================================================================
number:
  - platform: template
    name: "Target Port"
    id: target_peer_port
    min_value: 1024
    max_value: 65535
    step: 1
    initial_value: ${p2p_port}
    optimistic: true
    restore_value: true
    entity_category: diagnostic
    icon: "mdi:wan"

  - platform: template
    name: "Speaker Volume"
    id: speaker_volume
    min_value: 0
    max_value: 100
    step: 5
    initial_value: 70
    optimistic: true
    restore_value: true
    unit_of_measurement: "%"
    icon: "mdi:volume-high"
    set_action:
      - lambda: |-
          id(audio_component).set_volume(x / 100.0);
          ESP_LOGI("volume", "Volume: %.0f%%", x);

# =============================================================================
# BUTTONS
# =============================================================================
button:
  - platform: template
    name: "Refresh Peers"
    icon: "mdi:refresh"
    on_press:
      - lambda: id(discovery_component).scan_now();

  - platform: template
    name: "Next Peer"
    icon: "mdi:account-arrow-right"
    on_press:
      - lambda: |-
          auto& peers = id(discovery_component).get_peers();
          if (peers.empty()) {
            ESP_LOGW("peer", "No peers");
            return;
          }
          std::string current_ip = id(target_peer_ip).state;
          int current_idx = -1;
          for (size_t i = 0; i < peers.size(); i++) {
            if (peers[i].ip == current_ip) {
              current_idx = i;
              break;
            }
          }
          int next_idx = (current_idx + 1) % peers.size();
          auto call = id(target_peer_ip).make_call();
          call.set_value(peers[next_idx].ip);
          call.perform();
          ESP_LOGI("peer", "Selected: %s", peers[next_idx].name.c_str());

  - platform: restart
    name: "Restart"

# =============================================================================
# STATUS LED (WS2812 on GPIO21)
# =============================================================================
light:
  - platform: esp32_rmt_led_strip
    id: status_led
    name: "Status LED"
    pin: GPIO21
    chipset: WS2812
    num_leds: 1
    rgb_order: RGB
    effects:
      - pulse:
          name: "Fast Pulse"
          transition_length: 0.3s
          update_interval: 0.3s
          min_brightness: 0%
          max_brightness: 100%
