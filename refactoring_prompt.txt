# Refactoring del Componente ESPHome `udp_intercom` - Guida Completa

## Contesto e Obiettivo Finale

Hai creato un componente ESPHome chiamato `udp_intercom` che funziona, ma è un **monolite** che non verrà mai accettato nel branch principale di ESPHome. Il codice attuale mischia troppe responsabilità: driver I2S, networking UDP, mDNS discovery, state machine per modalità operative, auto-answer logic, peer selection, AEC, e molto altro.

**L'obiettivo è scomporre questo monolite in componenti separati, ognuno con una singola responsabilità, tutti potenzialmente candidabili per pull request separate verso ESPHome upstream.**

### Componenti da Creare

1. **`i2s_audio_udp`** - Bridge audio bidirezionale I2S ↔ UDP (componente CORE)
2. **`mdns_discovery`** - Query mDNS per scoprire servizi sulla rete locale
3. **`esp_aec`** - Acoustic Echo Cancellation wrapper

Tutto il resto (logica applicativa, selezione modalità, handshake P2P, auto-answer) deve essere gestito ESTERNAMENTE tramite:
- Componenti ESPHome nativi (`udp:`, `mdns:`, `select:`, `switch:`, `text_sensor:`, `text:`, `number:`)
- Automazioni YAML
- Lambda functions
- Substitutions

## Principi Guida INVIOLABILI

1. **Single Responsibility**: Ogni componente C++ fa UNA SOLA COSA
2. **No Business Logic**: Nessuna logica applicativa nei componenti C++
3. **No Reinventare la Ruota**: Se ESPHome ha già un componente nativo, USALO
4. **Valori Templatable**: IP, porte, etc. devono supportare valore fisso, substitution `${var}`, o `!lambda` - valutati al momento dello `start()`
5. **Triggers per Eventi**: I componenti espongono trigger, le automazioni decidono cosa fare
6. **Nessun Hardcoding**: Niente valori fissi nel C++, tutto configurabile
7. **Best Practices ESPHome**: Studia i componenti esistenti in ESPHome per capire pattern, struttura, naming conventions
8. **Sensori e Number Nativi**: Statistiche esposte come `sensor:`, volume come `number:` platform
9. **Actions Registrate**: `i2s_audio_udp.start` e `i2s_audio_udp.stop` come actions native ESPHome
10. **Configurazioni Parziali**: Supporta TX only, RX only, o Full Duplex in base ai pin dichiarati
11. **Deduzione Automatica**: I2S mode (single/dual) e audio mode (TX/RX/Full Duplex) dedotti automaticamente dai pin dichiarati

## Studio Preliminare OBBLIGATORIO

Prima di scrivere codice, devi studiare:

### Best Practices Componenti ESPHome

1. **Leggi la documentazione ufficiale**: https://esphome.io/components/external_components.html
2. **Studia componenti esistenti simili** nel repo ESPHome:
   - `esphome/components/i2s_audio/` - come gestiscono I2S
   - `esphome/components/udp/` - come gestiscono UDP
   - `esphome/components/mdns/` - come gestiscono mDNS
   - `esphome/components/media_player/` - pattern per audio
   - `esphome/components/sensor/` - come esporre sensori
   - `esphome/components/number/` - come esporre number platform
3. **Convenzioni di naming**:
   - File: `snake_case`
   - Classi: `PascalCase`
   - Metodi/variabili: `snake_case_`
   - Costanti: `UPPER_SNAKE_CASE`
4. **Struttura directory**:
   ```
   components/
   └── nome_componente/
       ├── __init__.py
       ├── nome_componente.h
       ├── nome_componente.cpp
       ├── sensor.py          # Se espone sensori
       └── number.py          # Se espone number
   ```
5. **Pattern per `cv.templatable()`**: Studia come altri componenti usano valori che possono essere fissi o lambda valutate a runtime

---

## FASE 1: Analisi e Inventario

### Task 1.1: Identifica tutte le funzionalità attuali

Esamina il codice attuale (`udp_intercom.cpp`, `udp_intercom.h`, `__init__.py`) e crea una lista completa di TUTTE le funzionalità presenti:

```
Per ogni funzionalità, documenta:
- Nome/descrizione
- File e linee di codice coinvolte
- Categoria: [CORE_AUDIO | NETWORKING | BUSINESS_LOGIC | UI_STATE | DISCOVERY | AEC]
- Verdetto: [MANTIENI_IN_i2s_audio_udp | SPOSTA_IN_mdns_discovery | SPOSTA_IN_esp_aec | SPOSTA_IN_YAML | USA_COMPONENTE_NATIVO | ELIMINA]
- Se "USA_COMPONENTE_NATIVO": quale componente ESPHome sostituisce questa funzionalità
```

### Task 1.2: Mappa i componenti ESPHome nativi disponibili

Verifica nella documentazione ESPHome quali componenti nativi possono sostituire funzionalità attualmente hardcodate:

| Funzionalità Attuale | Componente ESPHome Nativo | Note |
|---------------------|---------------------------|------|
| mDNS announce | `mdns:` con `services:` | Già integrato in ESPHome |
| mDNS query/discovery | **NESSUNO** → crea `mdns_discovery` | Componente nuovo da creare |
| UDP send datagram | `udp:` component | Per signaling/handshake |
| UDP receive datagram | `udp:` con `on_receive:` | Per auto-answer trigger |
| State machine (mode) | `select:` platform template | Con `on_value:` automation |
| Volume control HW | `es8311:` codec component | Se presente |
| Peer list display | `text_sensor:` template | Aggiornato via lambda |
| Boolean flags | `switch:` o `binary_sensor:` | Template platform |
| IP target | `text:` component | Input utente o da discovery |
| Porte | `number:` component | Input utente |
| AEC | **Separare** → crea `esp_aec` | Componente wrapper separato |
| TX/RX packets | `sensor:` platform | Esposti dal componente |
| Volume control | `number:` platform | Esposto dal componente |

### Task 1.3: Analizza pattern `cv.templatable()`

Studia nel codice ESPHome come altri componenti implementano `cv.templatable()` per accettare:
- Valore fisso: `remote_ip: "192.168.1.100"`
- Substitution: `remote_ip: "${go2rtc_server}"`
- Lambda: `remote_ip: !lambda 'return id(target_ip).state;'`

Il valore deve essere valutato al momento della chiamata `start()`, non al boot.

---

## FASE 2: Definizione Interfacce Componenti

### Task 2.1: Interfaccia `i2s_audio_udp` (Componente CORE)

**Deduzione Automatica I2S Mode e Audio Mode:**

Il componente NON ha parametri `i2s_mode` o `audio_mode`. Tutto viene dedotto dai pin dichiarati:

- **Single Bus vs Dual Bus**: Se l'utente dichiara pin `i2s_*` → single bus. Se dichiara pin `mic_*`/`speaker_*` → dual bus.
- **TX Only vs RX Only vs Full Duplex**: Se solo pin mic → TX Only. Se solo pin speaker → RX Only. Se entrambi → Full Duplex.

**Configurazione YAML:**

```yaml
i2s_audio_udp:
  id: audio_bridge
  sample_rate: 16000
  
  # ========== OPZIONE A: Single Bus (ES8311 o codec simili) ==========
  # Usa questi pin per bus I2S condiviso
  # I2S mode dedotto automaticamente dalla presenza di questi pin
  i2s_lrclk_pin: GPIOxx
  i2s_bclk_pin: GPIOxx
  i2s_mclk_pin: GPIOxx       # opzionale
  i2s_din_pin: GPIOxx        # mic - ometti se non hai mic
  i2s_dout_pin: GPIOxx       # speaker - ometti se non hai speaker
  
  # ========== OPZIONE B: Dual Bus (INMP441 + MAX98357A) ==========
  # Usa questi pin per bus I2S separati
  # I2S mode dedotto automaticamente dalla presenza di questi pin
  # NON MESCOLARE con pin i2s_* sopra
  mic_lrclk_pin: GPIOxx
  mic_bclk_pin: GPIOxx
  mic_din_pin: GPIOxx
  speaker_lrclk_pin: GPIOxx
  speaker_bclk_pin: GPIOxx
  speaker_dout_pin: GPIOxx
  
  # Microphone Settings (se hai il mic)
  # INMP441, SPH0645: bits=32, gain=4
  # ES8311: bits=16, gain=1
  mic_bits_per_sample: 16 | 32
  mic_channel: left | right
  mic_gain: 1-16
  
  # Speaker enable pin (opzionale)
  speaker_enable_pin: GPIOxx
  
  # Network - TEMPLATABLE (fisso, substitution, o lambda)
  # Valutati al momento dello start()
  remote_ip: "192.168.1.100"                          # Fisso
  # remote_ip: "${go2rtc_server}"                     # Da substitution
  # remote_ip: !lambda 'return id(target_ip).state;' # Da sensore
  remote_port: 12345
  listen_port: 12346
  
  # AEC - riferimento opzionale a componente esp_aec
  aec_id: my_aec  # Se omesso, niente AEC
  
  # Triggers
  on_start:
    - logger.log: "Stream started"
  on_stop:
    - logger.log: "Stream stopped"
  on_error:
    - logger.log: "Stream error"

# Sensori esposti dal componente (platform sensor)
sensor:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_bridge
    tx_packets:
      name: "TX Packets"
    rx_packets:
      name: "RX Packets"

# Volume esposto come number (platform number)
number:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_bridge
    volume:
      name: "Volume"
      min_value: 0
      max_value: 100
      step: 1

# Text sensor per modalità audio rilevata
text_sensor:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_bridge
    audio_mode:
      name: "Audio Mode"  # "TX Only", "RX Only", o "Full Duplex"
```

**Actions registrate (usabili in automazioni):**
```yaml
# Actions native, non serve lambda:
on_press:
  - i2s_audio_udp.start: audio_bridge
  
on_release:
  - i2s_audio_udp.stop: audio_bridge
```

**Metodi C++ (per casi complessi con lambda):**
```cpp
void start();
void stop();
bool is_streaming() const;
```

**Triggers esposti:**
```cpp
Trigger<> *get_on_start_trigger();
Trigger<> *get_on_stop_trigger();
Trigger<std::string> *get_on_error_trigger();  // Passa messaggio errore
```

**Comportamento:**
- All'avvio di `start()`, valuta i valori templatable (IP, porte) in quel momento
- Deduce automaticamente I2S mode (single/dual) dai pin dichiarati
- Deduce automaticamente audio mode (TX Only / RX Only / Full Duplex) dai pin dichiarati
- Se i valori sono vuoti o invalidi, triggera `on_error` e non parte
- Nessuna logica di retry, reconnect, o simili - se fallisce, triggera `on_error` e basta
- `loop()` deve essere VUOTO - nessuna logica applicativa

### Task 2.2: Supporto Configurazioni Parziali (TX Only / RX Only / Full Duplex)

Il componente deve supportare configurazioni hardware parziali. Non tutti gli utenti hanno sia microfono che speaker collegati. La modalità viene **dedotta automaticamente dai pin dichiarati**, non serve un parametro esplicito.

**Casi d'uso:**

1. **Solo microfono (TX Only)**: ESP con solo INMP441, invia audio a go2rtc o altro ESP
2. **Solo speaker (RX Only)**: ESP con solo MAX98357A, riceve audio da go2rtc o altro ESP
3. **Full Duplex**: ESP con entrambi, comunicazione bidirezionale

**Esempi configurazione:**

```yaml
# Caso 1: Solo microfono INMP441 (TX only, dual bus)
i2s_audio_udp:
  id: mic_only
  sample_rate: 16000
  mic_din_pin: GPIO7
  mic_bclk_pin: GPIO6
  mic_lrclk_pin: GPIO5
  mic_bits_per_sample: 32
  mic_channel: left
  mic_gain: 4
  # Nessun pin speaker → TX only, dual bus dedotti automaticamente
  remote_ip: "${go2rtc_server}"
  remote_port: 12345
  listen_port: 12346

# Caso 2: Solo microfono su ES8311 codec (TX only, single bus)
i2s_audio_udp:
  id: mic_only_codec
  sample_rate: 16000
  i2s_lrclk_pin: GPIO45
  i2s_bclk_pin: GPIO9
  i2s_mclk_pin: GPIO16
  i2s_din_pin: GPIO10
  # Nessun i2s_dout_pin → TX only, single bus dedotti automaticamente
  mic_bits_per_sample: 16
  mic_gain: 1
  remote_ip: "${go2rtc_server}"
  remote_port: 12345
  listen_port: 12346

# Caso 3: Solo speaker MAX98357A (RX only, dual bus)
i2s_audio_udp:
  id: speaker_only
  sample_rate: 16000
  speaker_dout_pin: GPIO10
  speaker_bclk_pin: GPIO9
  speaker_lrclk_pin: GPIO8
  speaker_enable_pin: GPIO46
  # Nessun pin mic → RX only, dual bus dedotti automaticamente
  remote_ip: "${go2rtc_server}"  # Ignorato in RX only ma può servire
  remote_port: 12345             # Ignorato in RX only
  listen_port: 12346

# Caso 4: Solo speaker su ES8311 (RX only, single bus)
i2s_audio_udp:
  id: speaker_only_codec
  sample_rate: 16000
  i2s_lrclk_pin: GPIO45
  i2s_bclk_pin: GPIO9
  i2s_mclk_pin: GPIO16
  i2s_dout_pin: GPIO8
  speaker_enable_pin: GPIO46
  # Nessun i2s_din_pin → RX only, single bus dedotti automaticamente
  remote_ip: "${go2rtc_server}"
  remote_port: 12345
  listen_port: 12346

# Caso 5: Full Duplex con bus separati (dual bus)
i2s_audio_udp:
  id: full_duplex
  sample_rate: 16000
  mic_din_pin: GPIO7
  mic_bclk_pin: GPIO6
  mic_lrclk_pin: GPIO5
  mic_bits_per_sample: 32
  mic_channel: left
  mic_gain: 4
  speaker_dout_pin: GPIO10
  speaker_bclk_pin: GPIO9
  speaker_lrclk_pin: GPIO8
  speaker_enable_pin: GPIO46
  # Entrambi i gruppi di pin → Full Duplex, dual bus dedotti automaticamente
  remote_ip: !lambda 'return id(target_ip).state;'
  remote_port: 12345
  listen_port: 12346

# Caso 6: Full Duplex con ES8311 codec (single bus)
i2s_audio_udp:
  id: full_duplex_codec
  sample_rate: 16000
  i2s_lrclk_pin: GPIO45
  i2s_bclk_pin: GPIO9
  i2s_mclk_pin: GPIO16
  i2s_din_pin: GPIO10
  i2s_dout_pin: GPIO8
  speaker_enable_pin: GPIO46
  mic_bits_per_sample: 16
  mic_gain: 1
  # Entrambi din e dout → Full Duplex, single bus dedotti automaticamente
  remote_ip: !lambda 'return id(target_ip).state;'
  remote_port: 12345
  listen_port: 12346
```

**Implementazione C++:**

```cpp
enum AudioMode : uint8_t {
  AUDIO_MODE_TX_ONLY,      // Solo microfono
  AUDIO_MODE_RX_ONLY,      // Solo speaker
  AUDIO_MODE_FULL_DUPLEX,  // Entrambi
};

void I2SAudioUDP::setup() {
  // Deduce I2S mode dai pin dichiarati
  bool is_single_bus = (this->i2s_lrclk_pin_ >= 0);
  
  // Deduce audio mode
  bool has_mic, has_speaker;
  
  if (is_single_bus) {
    has_mic = (this->i2s_din_pin_ >= 0);
    has_speaker = (this->i2s_dout_pin_ >= 0);
  } else {
    has_mic = (this->mic_din_pin_ >= 0);
    has_speaker = (this->speaker_dout_pin_ >= 0);
  }
  
  // Imposta audio mode
  if (has_mic && has_speaker) {
    this->audio_mode_ = AUDIO_MODE_FULL_DUPLEX;
    ESP_LOGI(TAG, "Audio mode: Full Duplex, I2S: %s", is_single_bus ? "Single Bus" : "Dual Bus");
  } else if (has_mic) {
    this->audio_mode_ = AUDIO_MODE_TX_ONLY;
    ESP_LOGI(TAG, "Audio mode: TX Only, I2S: %s", is_single_bus ? "Single Bus" : "Dual Bus");
  } else if (has_speaker) {
    this->audio_mode_ = AUDIO_MODE_RX_ONLY;
    ESP_LOGI(TAG, "Audio mode: RX Only, I2S: %s", is_single_bus ? "Single Bus" : "Dual Bus");
  } else {
    ESP_LOGE(TAG, "No audio pins configured!");
    this->mark_failed();
    return;
  }
  
  // Init I2S in base al bus type
  if (is_single_bus) {
    this->init_i2s_single_bus_();
  } else {
    this->init_i2s_dual_bus_();
  }
  
  // Pubblica audio mode sul text sensor
  if (this->audio_mode_sensor_ != nullptr) {
    this->audio_mode_sensor_->publish_state(this->get_audio_mode_str());
  }
}
```

**Audio task adattivo:**

```cpp
void I2SAudioUDP::audio_task_(void *params) {
  auto *self = (I2SAudioUDP *)params;
  
  while (self->streaming_) {
    // TX: Mic → UDP (solo se ha mic)
    if (self->audio_mode_ == AUDIO_MODE_TX_ONLY || 
        self->audio_mode_ == AUDIO_MODE_FULL_DUPLEX) {
      // Leggi da I2S mic
      // Applica AEC se full duplex e AEC abilitato
      // Invia via UDP
    }
    
    // RX: UDP → Speaker (solo se ha speaker)
    if (self->audio_mode_ == AUDIO_MODE_RX_ONLY || 
        self->audio_mode_ == AUDIO_MODE_FULL_DUPLEX) {
      // Ricevi da UDP (jitter buffer)
      // Applica volume
      // Scrivi su I2S speaker
    }
  }
}
```

**Validazione in `__init__.py`:**

```python
def validate_config(config):
    """Deduce I2S mode e audio mode, valida pin."""
    
    single_bus_pins = [CONF_I2S_LRCLK_PIN, CONF_I2S_BCLK_PIN, CONF_I2S_DIN_PIN, CONF_I2S_DOUT_PIN, CONF_I2S_MCLK_PIN]
    dual_bus_pins = [CONF_MIC_LRCLK_PIN, CONF_MIC_BCLK_PIN, CONF_MIC_DIN_PIN,
                     CONF_SPEAKER_LRCLK_PIN, CONF_SPEAKER_BCLK_PIN, CONF_SPEAKER_DOUT_PIN]
    
    has_single_bus_pins = any(pin in config for pin in single_bus_pins)
    has_dual_bus_pins = any(pin in config for pin in dual_bus_pins)
    
    if has_single_bus_pins and has_dual_bus_pins:
        raise cv.Invalid(
            "Cannot mix single bus pins (i2s_*) with dual bus pins (mic_*/speaker_*). "
            "Use i2s_* for shared bus (ES8311) or mic_*/speaker_* for separate buses (INMP441+MAX98357A)."
        )
    
    if not has_single_bus_pins and not has_dual_bus_pins:
        raise cv.Invalid(
            "Must specify audio pins. Use i2s_* for single bus or mic_*/speaker_* for dual bus."
        )
    
    if has_dual_bus_pins:
        has_mic = CONF_MIC_DIN_PIN in config
        has_speaker = CONF_SPEAKER_DOUT_PIN in config
        
        if has_mic:
            for pin in [CONF_MIC_DIN_PIN, CONF_MIC_BCLK_PIN, CONF_MIC_LRCLK_PIN]:
                if pin not in config:
                    raise cv.Invalid(f"'{pin}' required when using mic")
        
        if has_speaker:
            for pin in [CONF_SPEAKER_DOUT_PIN, CONF_SPEAKER_BCLK_PIN, CONF_SPEAKER_LRCLK_PIN]:
                if pin not in config:
                    raise cv.Invalid(f"'{pin}' required when using speaker")
        
        if not has_mic and not has_speaker:
            raise cv.Invalid("Must specify mic_din_pin and/or speaker_dout_pin")
    
    if has_single_bus_pins:
        has_mic = CONF_I2S_DIN_PIN in config
        has_speaker = CONF_I2S_DOUT_PIN in config
        
        for pin in [CONF_I2S_LRCLK_PIN, CONF_I2S_BCLK_PIN]:
            if pin not in config:
                raise cv.Invalid(f"'{pin}' required for single bus mode")
        
        if not has_mic and not has_speaker:
            raise cv.Invalid("Must specify i2s_din_pin and/or i2s_dout_pin")
    
    return config
```

### Task 2.3: Interfaccia `mdns_discovery` (Componente Nuovo)

Questo componente NON esiste in ESPHome, quindi va creato seguendo le best practices.

**Configurazione YAML:**

```yaml
mdns_discovery:
  id: peer_discovery
  
  # Servizio da cercare
  service_type: "_intercom._udp"
  
  # Intervallo di scan
  scan_interval: 10s
  
  # Timeout per considerare un peer "perso"
  peer_timeout: 60s
  
  # Triggers
  on_peer_found:
    - logger.log: 
        format: "Found: %s at %s:%d"
        args: ['name.c_str()', 'ip.c_str()', 'port']
  on_peer_lost:
    - logger.log:
        format: "Lost: %s"
        args: ['name.c_str()']
  on_scan_complete:
    - logger.log:
        format: "Scan complete, found %d peers"
        args: ['peer_count']

# Sensori esposti dal componente
sensor:
  - platform: mdns_discovery
    mdns_discovery_id: peer_discovery
    peer_count:
      name: "Peer Count"

# Text sensor per lista peer
text_sensor:
  - platform: mdns_discovery
    mdns_discovery_id: peer_discovery
    peers_list:
      name: "Discovered Peers"
```

**Actions registrate:**

```yaml
on_press:
  - mdns_discovery.scan: peer_discovery
```

**Metodi C++ (per lambda):**

```cpp
void scan_now();
int get_peer_count() const;
std::string get_peer_ip(int index) const;
std::string get_peer_ip_by_name(const std::string &name) const;
uint16_t get_peer_port(int index) const;
std::string get_peers_list() const;
```

**Triggers:**

```cpp
Trigger<std::string, std::string, uint16_t> *get_on_peer_found_trigger();
Trigger<std::string> *get_on_peer_lost_trigger();
Trigger<int> *get_on_scan_complete_trigger();
```

### Task 2.4: Interfaccia `esp_aec` (Componente Separato)

Wrapper per ESP-AEC, completamente separato dal componente audio.

**Configurazione YAML:**

```yaml
esp_aec:
  id: my_aec
  sample_rate: 16000
  filter_length: 4  # opzionale
```

**Metodi C++ (usati internamente da i2s_audio_udp):**

```cpp
void process(int16_t *mic_input, int16_t *speaker_ref, int16_t *output, size_t samples);
int get_frame_size() const;
```

**Integrazione con `i2s_audio_udp`:**

```yaml
esp_aec:
  id: my_aec
  sample_rate: 16000

i2s_audio_udp:
  id: audio_bridge
  aec_id: my_aec  # Riferimento opzionale
  # ...resto config...
```

---

## FASE 3: Refactoring del Codice C++

### Task 3.1: Crea struttura directory

```
custom_components/
├── i2s_audio_udp/
│   ├── __init__.py
│   ├── i2s_audio_udp.h
│   ├── i2s_audio_udp.cpp
│   ├── sensor.py           # Platform sensor per TX/RX packets
│   ├── number.py           # Platform number per volume
│   └── text_sensor.py      # Platform text_sensor per audio_mode
├── mdns_discovery/
│   ├── __init__.py
│   ├── mdns_discovery.h
│   ├── mdns_discovery.cpp
│   ├── sensor.py           # Platform sensor per peer_count
│   └── text_sensor.py      # Platform text_sensor per peers_list
└── esp_aec/
    ├── __init__.py
    ├── esp_aec.h
    └── esp_aec.cpp
```

### Task 3.2: Implementa `i2s_audio_udp`

**Codice da RIMUOVERE completamente (rispetto al vecchio `udp_intercom`):**

```cpp
// ELIMINA TUTTO QUESTO:
enum OperatingMode  // VIA - gestito da YAML
enum I2SMode  // VIA - dedotto automaticamente
struct PeerInfo  // VIA - gestito da mdns_discovery
void mdns_query_peers_()  // VIA - usa mdns_discovery
void cleanup_stale_peers_()  // VIA
void refresh_peers()  // VIA
void call_peer()  // VIA - la logica è in YAML
void select_next_peer()  // VIA
void select_previous_peer()  // VIA
std::string get_peers_list()  // VIA - usa mdns_discovery
void set_operating_mode()  // VIA
void set_i2s_mode()  // VIA - dedotto automaticamente
void set_p2p_enabled()  // VIA
void set_p2p_service_name()  // VIA
void set_p2p_auto_answer()  // VIA
void set_p2p_timeout()  // VIA
bool call_target()  // VIA
std::string get_target_description()  // VIA
std::vector<PeerInfo> discovered_peers_  // VIA
int selected_peer_index_  // VIA
int target_index_  // VIA
CallbackManager<void(std::string, std::string)> peer_discovered_callbacks_  // VIA
CallbackManager<void(std::string)> peer_lost_callbacks_  // VIA

// TUTTO il blocco auto-answer in loop() // VIA
// TUTTO il blocco peer discovery in loop() // VIA
// TUTTA la logica P2P vs go2rtc // VIA
```

**Codice da MANTENERE (e pulire):**

```cpp
// MANTIENI:
// - I2S init/deinit (single bus e dual bus) - dedotto automaticamente
// - Socket UDP per AUDIO (non signaling)
// - Jitter buffer
// - Audio task (adattivo per TX/RX/Full Duplex)
// - Software volume
// - Triggers base (on_start, on_stop, on_error)
// - Statistiche TX/RX packets
// - Deduzione automatica audio mode e I2S mode
```

**`i2s_audio_udp.h` - Struttura finale:**

```cpp
#pragma once

#include "esphome/core/component.h"
#include "esphome/core/automation.h"
#include "esphome/components/sensor/sensor.h"
#include "esphome/components/number/number.h"
#include "esphome/components/text_sensor/text_sensor.h"

namespace esphome {
namespace esp_aec {
class EspAec;
}
}

namespace esphome {
namespace i2s_audio_udp {

enum MicChannel : uint8_t {
  MIC_CHANNEL_LEFT,
  MIC_CHANNEL_RIGHT,
};

enum AudioMode : uint8_t {
  AUDIO_MODE_TX_ONLY,
  AUDIO_MODE_RX_ONLY,
  AUDIO_MODE_FULL_DUPLEX,
};

class I2SAudioUDP : public Component {
 public:
  void setup() override;
  void loop() override {}  // VUOTO
  void dump_config() override;
  float get_setup_priority() const override { return setup_priority::AFTER_WIFI; }

  // Configurazione sample rate
  void set_sample_rate(uint32_t rate) { this->sample_rate_ = rate; }
  
  // Pin single bus (i2s_*)
  void set_i2s_lrclk_pin(int pin) { this->i2s_lrclk_pin_ = pin; }
  void set_i2s_bclk_pin(int pin) { this->i2s_bclk_pin_ = pin; }
  void set_i2s_mclk_pin(int pin) { this->i2s_mclk_pin_ = pin; }
  void set_i2s_din_pin(int pin) { this->i2s_din_pin_ = pin; }
  void set_i2s_dout_pin(int pin) { this->i2s_dout_pin_ = pin; }
  
  // Pin dual bus (mic_*/speaker_*)
  void set_mic_lrclk_pin(int pin) { this->mic_lrclk_pin_ = pin; }
  void set_mic_bclk_pin(int pin) { this->mic_bclk_pin_ = pin; }
  void set_mic_din_pin(int pin) { this->mic_din_pin_ = pin; }
  void set_speaker_lrclk_pin(int pin) { this->speaker_lrclk_pin_ = pin; }
  void set_speaker_bclk_pin(int pin) { this->speaker_bclk_pin_ = pin; }
  void set_speaker_dout_pin(int pin) { this->speaker_dout_pin_ = pin; }
  
  // Mic config
  void set_mic_bits_per_sample(int bits) { this->mic_bits_per_sample_ = bits; }
  void set_mic_channel(MicChannel ch) { this->mic_channel_ = ch; }
  void set_mic_gain(int gain) { this->mic_gain_ = gain; }
  
  // Hardware
  void set_speaker_enable_pin(int pin) { this->speaker_enable_pin_ = pin; }
  
  // Network - templatable
  void set_remote_ip(std::function<std::string()> &&f) { this->remote_ip_func_ = std::move(f); }
  void set_remote_ip(const std::string &ip) { this->remote_ip_func_ = [ip]() { return ip; }; }
  void set_remote_port(std::function<uint16_t()> &&f) { this->remote_port_func_ = std::move(f); }
  void set_remote_port(uint16_t port) { this->remote_port_func_ = [port]() { return port; }; }
  void set_listen_port(std::function<uint16_t()> &&f) { this->listen_port_func_ = std::move(f); }
  void set_listen_port(uint16_t port) { this->listen_port_func_ = [port]() { return port; }; }
  
  // AEC
  void set_aec(esp_aec::EspAec *aec) { this->aec_ = aec; }
  
  // Sensori
  void set_tx_packets_sensor(sensor::Sensor *sens) { this->tx_packets_sensor_ = sens; }
  void set_rx_packets_sensor(sensor::Sensor *sens) { this->rx_packets_sensor_ = sens; }
  void set_audio_mode_text_sensor(text_sensor::TextSensor *sens) { this->audio_mode_sensor_ = sens; }
  
  // Volume
  void set_volume_number(number::Number *num) { this->volume_number_ = num; }
  void set_volume(float vol);
  float get_volume() const { return this->volume_; }
  
  // Controllo
  void start();
  void stop();
  bool is_streaming() const { return this->streaming_; }
  
  // Stats
  uint32_t get_tx_packets() const { return this->tx_packets_; }
  uint32_t get_rx_packets() const { return this->rx_packets_; }
  
  // Audio mode
  AudioMode get_audio_mode() const { return this->audio_mode_; }
  const char *get_audio_mode_str() const;
  
  // Triggers
  Trigger<> *get_on_start_trigger() { return &this->on_start_trigger_; }
  Trigger<> *get_on_stop_trigger() { return &this->on_stop_trigger_; }
  Trigger<std::string> *get_on_error_trigger() { return &this->on_error_trigger_; }

 protected:
  void deduce_modes_();
  bool init_i2s_single_bus_();
  bool init_i2s_dual_bus_();
  void deinit_i2s_();
  bool init_sockets_();
  void close_sockets_();
  void apply_software_volume_(int16_t *buffer, size_t samples);
  void update_sensors_();
  
  static void audio_task_(void *params);
  
  // Config
  uint32_t sample_rate_{16000};
  
  // Pin single bus
  int i2s_lrclk_pin_{-1};
  int i2s_bclk_pin_{-1};
  int i2s_mclk_pin_{-1};
  int i2s_din_pin_{-1};
  int i2s_dout_pin_{-1};
  
  // Pin dual bus
  int mic_lrclk_pin_{-1};
  int mic_bclk_pin_{-1};
  int mic_din_pin_{-1};
  int speaker_lrclk_pin_{-1};
  int speaker_bclk_pin_{-1};
  int speaker_dout_pin_{-1};
  
  // Mic config
  int mic_bits_per_sample_{16};
  MicChannel mic_channel_{MIC_CHANNEL_LEFT};
  int mic_gain_{1};
  int speaker_enable_pin_{-1};
  
  // Network
  std::function<std::string()> remote_ip_func_;
  std::function<uint16_t()> remote_port_func_;
  std::function<uint16_t()> listen_port_func_;
  
  // AEC
  esp_aec::EspAec *aec_{nullptr};
  
  // Sensori
  sensor::Sensor *tx_packets_sensor_{nullptr};
  sensor::Sensor *rx_packets_sensor_{nullptr};
  text_sensor::TextSensor *audio_mode_sensor_{nullptr};
  number::Number *volume_number_{nullptr};
  
  // Runtime - dedotti automaticamente
  bool is_single_bus_{false};
  AudioMode audio_mode_{AUDIO_MODE_FULL_DUPLEX};
  volatile bool streaming_{false};
  float volume_{0.7f};
  volatile uint32_t tx_packets_{0};
  volatile uint32_t rx_packets_{0};
  
  // I2S
  i2s_chan_handle_t tx_handle_{nullptr};
  i2s_chan_handle_t rx_handle_{nullptr};
  
  // Sockets
  int send_socket_{-1};
  int recv_socket_{-1};
  struct sockaddr_in remote_addr_;
  
  // Task
  TaskHandle_t audio_task_handle_{nullptr};
  
  // Triggers
  Trigger<> on_start_trigger_;
  Trigger<> on_stop_trigger_;
  Trigger<std::string> on_error_trigger_;
};

// Actions
template<typename... Ts>
class StartAction : public Action<Ts...>, public Parented<I2SAudioUDP> {
 public:
  void play(Ts... x) override { this->parent_->start(); }
};

template<typename... Ts>
class StopAction : public Action<Ts...>, public Parented<I2SAudioUDP> {
 public:
  void play(Ts... x) override { this->parent_->stop(); }
};

}  // namespace i2s_audio_udp
}  // namespace esphome
```

### Task 3.3: Implementa `__init__.py` per `i2s_audio_udp`

```python
import esphome.codegen as cg
import esphome.config_validation as cv
from esphome import automation
from esphome.const import CONF_ID

CODEOWNERS = ["@tuonome"]
DEPENDENCIES = ["network"]
AUTO_LOAD = ["sensor", "number", "text_sensor"]

# Pin single bus
CONF_I2S_LRCLK_PIN = "i2s_lrclk_pin"
CONF_I2S_BCLK_PIN = "i2s_bclk_pin"
CONF_I2S_MCLK_PIN = "i2s_mclk_pin"
CONF_I2S_DIN_PIN = "i2s_din_pin"
CONF_I2S_DOUT_PIN = "i2s_dout_pin"

# Pin dual bus
CONF_MIC_LRCLK_PIN = "mic_lrclk_pin"
CONF_MIC_BCLK_PIN = "mic_bclk_pin"
CONF_MIC_DIN_PIN = "mic_din_pin"
CONF_SPEAKER_LRCLK_PIN = "speaker_lrclk_pin"
CONF_SPEAKER_BCLK_PIN = "speaker_bclk_pin"
CONF_SPEAKER_DOUT_PIN = "speaker_dout_pin"

# Altri config
CONF_SAMPLE_RATE = "sample_rate"
CONF_MIC_BITS_PER_SAMPLE = "mic_bits_per_sample"
CONF_MIC_CHANNEL = "mic_channel"
CONF_MIC_GAIN = "mic_gain"
CONF_SPEAKER_ENABLE_PIN = "speaker_enable_pin"
CONF_REMOTE_IP = "remote_ip"
CONF_REMOTE_PORT = "remote_port"
CONF_LISTEN_PORT = "listen_port"
CONF_AEC_ID = "aec_id"
CONF_ON_START = "on_start"
CONF_ON_STOP = "on_stop"
CONF_ON_ERROR = "on_error"

i2s_audio_udp_ns = cg.esphome_ns.namespace("i2s_audio_udp")
I2SAudioUDP = i2s_audio_udp_ns.class_("I2SAudioUDP", cg.Component)

MicChannel = i2s_audio_udp_ns.enum("MicChannel")
MIC_CHANNELS = {
    "left": MicChannel.MIC_CHANNEL_LEFT,
    "right": MicChannel.MIC_CHANNEL_RIGHT,
}

StartAction = i2s_audio_udp_ns.class_("StartAction", automation.Action)
StopAction = i2s_audio_udp_ns.class_("StopAction", automation.Action)

esp_aec_ns = cg.esphome_ns.namespace("esp_aec")
EspAec = esp_aec_ns.class_("EspAec")


def validate_config(config):
    """Deduce I2S mode e audio mode, valida pin."""
    
    single_bus_pins = [CONF_I2S_LRCLK_PIN, CONF_I2S_BCLK_PIN, CONF_I2S_DIN_PIN, CONF_I2S_DOUT_PIN, CONF_I2S_MCLK_PIN]
    dual_bus_pins = [CONF_MIC_LRCLK_PIN, CONF_MIC_BCLK_PIN, CONF_MIC_DIN_PIN,
                     CONF_SPEAKER_LRCLK_PIN, CONF_SPEAKER_BCLK_PIN, CONF_SPEAKER_DOUT_PIN]
    
    has_single_bus_pins = any(pin in config for pin in single_bus_pins)
    has_dual_bus_pins = any(pin in config for pin in dual_bus_pins)
    
    if has_single_bus_pins and has_dual_bus_pins:
        raise cv.Invalid(
            "Cannot mix single bus pins (i2s_*) with dual bus pins (mic_*/speaker_*). "
            "Use i2s_* for shared bus (ES8311) or mic_*/speaker_* for separate buses (INMP441+MAX98357A)."
        )
    
    if not has_single_bus_pins and not has_dual_bus_pins:
        raise cv.Invalid(
            "Must specify audio pins. Use i2s_* for single bus or mic_*/speaker_* for dual bus."
        )
    
    if has_dual_bus_pins:
        has_mic = CONF_MIC_DIN_PIN in config
        has_speaker = CONF_SPEAKER_DOUT_PIN in config
        
        if has_mic:
            for pin in [CONF_MIC_DIN_PIN, CONF_MIC_BCLK_PIN, CONF_MIC_LRCLK_PIN]:
                if pin not in config:
                    raise cv.Invalid(f"'{pin}' required when using mic")
        
        if has_speaker:
            for pin in [CONF_SPEAKER_DOUT_PIN, CONF_SPEAKER_BCLK_PIN, CONF_SPEAKER_LRCLK_PIN]:
                if pin not in config:
                    raise cv.Invalid(f"'{pin}' required when using speaker")
        
        if not has_mic and not has_speaker:
            raise cv.Invalid("Must specify mic_din_pin and/or speaker_dout_pin")
    
    if has_single_bus_pins:
        has_mic = CONF_I2S_DIN_PIN in config
        has_speaker = CONF_I2S_DOUT_PIN in config
        
        for pin in [CONF_I2S_LRCLK_PIN, CONF_I2S_BCLK_PIN]:
            if pin not in config:
                raise cv.Invalid(f"'{pin}' required for single bus mode")
        
        if not has_mic and not has_speaker:
            raise cv.Invalid("Must specify i2s_din_pin and/or i2s_dout_pin")
    
    return config


CONFIG_SCHEMA = cv.All(
    cv.Schema({
        cv.GenerateID(): cv.declare_id(I2SAudioUDP),
        
        cv.Optional(CONF_SAMPLE_RATE, default=16000): cv.int_range(min=8000, max=48000),
        
        # Single bus pins
        cv.Optional(CONF_I2S_LRCLK_PIN): cv.int_,
        cv.Optional(CONF_I2S_BCLK_PIN): cv.int_,
        cv.Optional(CONF_I2S_MCLK_PIN): cv.int_,
        cv.Optional(CONF_I2S_DIN_PIN): cv.int_,
        cv.Optional(CONF_I2S_DOUT_PIN): cv.int_,
        
        # Dual bus pins
        cv.Optional(CONF_MIC_LRCLK_PIN): cv.int_,
        cv.Optional(CONF_MIC_BCLK_PIN): cv.int_,
        cv.Optional(CONF_MIC_DIN_PIN): cv.int_,
        cv.Optional(CONF_SPEAKER_LRCLK_PIN): cv.int_,
        cv.Optional(CONF_SPEAKER_BCLK_PIN): cv.int_,
        cv.Optional(CONF_SPEAKER_DOUT_PIN): cv.int_,
        
        # Mic config
        cv.Optional(CONF_MIC_BITS_PER_SAMPLE, default=16): cv.one_of(16, 32, int=True),
        cv.Optional(CONF_MIC_CHANNEL, default="left"): cv.enum(MIC_CHANNELS, lower=True),
        cv.Optional(CONF_MIC_GAIN, default=1): cv.int_range(min=1, max=16),
        
        # Hardware
        cv.Optional(CONF_SPEAKER_ENABLE_PIN): cv.int_,
        
        # Network - TEMPLATABLE
        cv.Required(CONF_REMOTE_IP): cv.templatable(cv.string),
        cv.Required(CONF_REMOTE_PORT): cv.templatable(cv.port),
        cv.Required(CONF_LISTEN_PORT): cv.templatable(cv.port),
        
        # AEC
        cv.Optional(CONF_AEC_ID): cv.use_id(EspAec),
        
        # Triggers
        cv.Optional(CONF_ON_START): automation.validate_automation(single=True),
        cv.Optional(CONF_ON_STOP): automation.validate_automation(single=True),
        cv.Optional(CONF_ON_ERROR): automation.validate_automation(single=True),
    }).extend(cv.COMPONENT_SCHEMA),
    validate_config,
)


async def to_code(config):
    var = cg.new_Pvariable(config[CONF_ID])
    await cg.register_component(var, config)
    
    cg.add(var.set_sample_rate(config[CONF_SAMPLE_RATE]))
    
    # Single bus pins
    if CONF_I2S_LRCLK_PIN in config:
        cg.add(var.set_i2s_lrclk_pin(config[CONF_I2S_LRCLK_PIN]))
    if CONF_I2S_BCLK_PIN in config:
        cg.add(var.set_i2s_bclk_pin(config[CONF_I2S_BCLK_PIN]))
    if CONF_I2S_MCLK_PIN in config:
        cg.add(var.set_i2s_mclk_pin(config[CONF_I2S_MCLK_PIN]))
    if CONF_I2S_DIN_PIN in config:
        cg.add(var.set_i2s_din_pin(config[CONF_I2S_DIN_PIN]))
    if CONF_I2S_DOUT_PIN in config:
        cg.add(var.set_i2s_dout_pin(config[CONF_I2S_DOUT_PIN]))
    
    # Dual bus pins
    if CONF_MIC_LRCLK_PIN in config:
        cg.add(var.set_mic_lrclk_pin(config[CONF_MIC_LRCLK_PIN]))
    if CONF_MIC_BCLK_PIN in config:
        cg.add(var.set_mic_bclk_pin(config[CONF_MIC_BCLK_PIN]))
    if CONF_MIC_DIN_PIN in config:
        cg.add(var.set_mic_din_pin(config[CONF_MIC_DIN_PIN]))
    if CONF_SPEAKER_LRCLK_PIN in config:
        cg.add(var.set_speaker_lrclk_pin(config[CONF_SPEAKER_LRCLK_PIN]))
    if CONF_SPEAKER_BCLK_PIN in config:
        cg.add(var.set_speaker_bclk_pin(config[CONF_SPEAKER_BCLK_PIN]))
    if CONF_SPEAKER_DOUT_PIN in config:
        cg.add(var.set_speaker_dout_pin(config[CONF_SPEAKER_DOUT_PIN]))
    
    # Mic config
    cg.add(var.set_mic_bits_per_sample(config[CONF_MIC_BITS_PER_SAMPLE]))
    cg.add(var.set_mic_channel(config[CONF_MIC_CHANNEL]))
    cg.add(var.set_mic_gain(config[CONF_MIC_GAIN]))
    
    # Hardware
    if CONF_SPEAKER_ENABLE_PIN in config:
        cg.add(var.set_speaker_enable_pin(config[CONF_SPEAKER_ENABLE_PIN]))
    
    # Network - templatable
    remote_ip = await cg.templatable(config[CONF_REMOTE_IP], [], cg.std_string)
    cg.add(var.set_remote_ip(remote_ip))
    
    remote_port = await cg.templatable(config[CONF_REMOTE_PORT], [], cg.uint16)
    cg.add(var.set_remote_port(remote_port))
    
    listen_port = await cg.templatable(config[CONF_LISTEN_PORT], [], cg.uint16)
    cg.add(var.set_listen_port(listen_port))
    
    # AEC
    if CONF_AEC_ID in config:
        aec = await cg.get_variable(config[CONF_AEC_ID])
        cg.add(var.set_aec(aec))
    
    # Triggers
    if CONF_ON_START in config:
        await automation.build_automation(
            var.get_on_start_trigger(), [], config[CONF_ON_START]
        )
    if CONF_ON_STOP in config:
        await automation.build_automation(
            var.get_on_stop_trigger(), [], config[CONF_ON_STOP]
        )
    if CONF_ON_ERROR in config:
        await automation.build_automation(
            var.get_on_error_trigger(), [(cg.std_string, "error")], config[CONF_ON_ERROR]
        )


@automation.register_action(
    "i2s_audio_udp.start",
    StartAction,
    cv.Schema({
        cv.GenerateID(): cv.use_id(I2SAudioUDP),
    }),
)
async def start_action_to_code(config, action_id, template_arg, args):
    var = cg.new_Pvariable(action_id, template_arg)
    await cg.register_parented(var, config[CONF_ID])
    return var


@automation.register_action(
    "i2s_audio_udp.stop",
    StopAction,
    cv.Schema({
        cv.GenerateID(): cv.use_id(I2SAudioUDP),
    }),
)
async def stop_action_to_code(config, action_id, template_arg, args):
    var = cg.new_Pvariable(action_id, template_arg)
    await cg.register_parented(var, config[CONF_ID])
    return var
```

### Task 3.4: Implementa platform files per `i2s_audio_udp`

Crea `sensor.py`, `number.py`, `text_sensor.py` seguendo i pattern ESPHome esistenti per esporre TX/RX packets, volume, e audio_mode.

### Task 3.5: Implementa `mdns_discovery`

Crea il componente completo con:
- Query mDNS periodiche
- Lista peer interna
- Sensori (peer_count)
- Text sensor (peers_list)
- Triggers (on_peer_found, on_peer_lost, on_scan_complete)
- Action (mdns_discovery.scan)

### Task 3.6: Implementa `esp_aec`

Wrapper minimale per ESP-AFE AEC:
- setup() per init
- loop() vuoto
- process() per elaborare frame
- get_frame_size()

---

## FASE 4: Creazione Esempi YAML

### Task 4.1: Esempio go2rtc Full Duplex (Dual Bus)

```yaml
# examples/go2rtc_full_duplex_dual.yaml

substitutions:
  device_name: "intercom-door"
  go2rtc_server: "192.168.1.50"

esphome:
  name: ${device_name}

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

i2s_audio_udp:
  id: audio_bridge
  sample_rate: 16000
  # Dual bus dedotto automaticamente da mic_*/speaker_* pins
  mic_lrclk_pin: GPIO5
  mic_bclk_pin: GPIO6
  mic_din_pin: GPIO7
  mic_bits_per_sample: 32
  mic_channel: left
  mic_gain: 4
  speaker_lrclk_pin: GPIO8
  speaker_bclk_pin: GPIO9
  speaker_dout_pin: GPIO10
  speaker_enable_pin: GPIO46
  remote_ip: "${go2rtc_server}"
  remote_port: 12345
  listen_port: 12346
  on_start:
    - logger.log: "Streaming started"
  on_stop:
    - logger.log: "Streaming stopped"

sensor:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_bridge
    tx_packets:
      name: "TX Packets"
    rx_packets:
      name: "RX Packets"

number:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_bridge
    volume:
      name: "Volume"

text_sensor:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_bridge
    audio_mode:
      name: "Audio Mode"  # Mostrerà "Full Duplex"

switch:
  - platform: template
    name: "Intercom"
    turn_on_action:
      - i2s_audio_udp.start: audio_bridge
    turn_off_action:
      - i2s_audio_udp.stop: audio_bridge
    lambda: 'return id(audio_bridge).is_streaming();'

binary_sensor:
  - platform: gpio
    pin: GPIO0
    name: "Doorbell"
    on_press:
      - homeassistant.event:
          event: esphome.doorbell_ring
```

### Task 4.2: Esempio go2rtc Full Duplex (Single Bus ES8311)

```yaml
# examples/go2rtc_full_duplex_single.yaml

substitutions:
  device_name: "intercom-es8311"
  go2rtc_server: "192.168.1.50"

esphome:
  name: ${device_name}

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

i2s_audio_udp:
  id: audio_bridge
  sample_rate: 16000
  # Single bus dedotto automaticamente da i2s_* pins
  i2s_lrclk_pin: GPIO45
  i2s_bclk_pin: GPIO9
  i2s_mclk_pin: GPIO16
  i2s_din_pin: GPIO10
  i2s_dout_pin: GPIO8
  speaker_enable_pin: GPIO46
  mic_bits_per_sample: 16
  mic_gain: 1
  remote_ip: "${go2rtc_server}"
  remote_port: 12345
  listen_port: 12346

sensor:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_bridge
    tx_packets:
      name: "TX Packets"
    rx_packets:
      name: "RX Packets"

number:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_bridge
    volume:
      name: "Volume"

text_sensor:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_bridge
    audio_mode:
      name: "Audio Mode"

switch:
  - platform: template
    name: "Intercom"
    turn_on_action:
      - i2s_audio_udp.start: audio_bridge
    turn_off_action:
      - i2s_audio_udp.stop: audio_bridge
```

### Task 4.3: Esempio TX Only (Baby Monitor Mic)

```yaml
# examples/baby_monitor_mic.yaml

substitutions:
  device_name: "baby-room-mic"
  ha_server: "192.168.1.50"

esphome:
  name: ${device_name}

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

i2s_audio_udp:
  id: audio_tx
  sample_rate: 16000
  # TX Only e Dual bus dedotti automaticamente
  mic_lrclk_pin: GPIO5
  mic_bclk_pin: GPIO6
  mic_din_pin: GPIO7
  mic_bits_per_sample: 32
  mic_channel: left
  mic_gain: 8  # Gain alto per sentire bene
  remote_ip: "${ha_server}"
  remote_port: 12345
  listen_port: 12346

sensor:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_tx
    tx_packets:
      name: "TX Packets"

text_sensor:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_tx
    audio_mode:
      name: "Audio Mode"  # Mostrerà "TX Only"

switch:
  - platform: template
    name: "Baby Monitor"
    turn_on_action:
      - i2s_audio_udp.start: audio_tx
    turn_off_action:
      - i2s_audio_udp.stop: audio_tx
```

### Task 4.4: Esempio RX Only (Baby Monitor Speaker)

```yaml
# examples/baby_monitor_speaker.yaml

substitutions:
  device_name: "living-room-speaker"

esphome:
  name: ${device_name}

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

i2s_audio_udp:
  id: audio_rx
  sample_rate: 16000
  # RX Only e Dual bus dedotti automaticamente
  speaker_lrclk_pin: GPIO8
  speaker_bclk_pin: GPIO9
  speaker_dout_pin: GPIO10
  speaker_enable_pin: GPIO46
  remote_ip: "0.0.0.0"  # Non usato in RX
  remote_port: 12345    # Non usato in RX
  listen_port: 12346

sensor:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_rx
    rx_packets:
      name: "RX Packets"

number:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_rx
    volume:
      name: "Baby Monitor Volume"

text_sensor:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_rx
    audio_mode:
      name: "Audio Mode"  # Mostrerà "RX Only"

switch:
  - platform: template
    name: "Listen"
    turn_on_action:
      - i2s_audio_udp.start: audio_rx
    turn_off_action:
      - i2s_audio_udp.stop: audio_rx
```

### Task 4.5: Esempio P2P Completo con Tre Modalità

```yaml
# examples/p2p_intercom.yaml

substitutions:
  device_name: "intercom-kitchen"
  go2rtc_server: "192.168.1.50"
  go2rtc_port: "12345"
  p2p_port: "12346"

esphome:
  name: ${device_name}

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

# Annuncia questo dispositivo via mDNS
mdns:
  services:
    - service: "_intercom"
      protocol: "_udp"
      port: ${p2p_port}
      txt:
        name: ${device_name}

# Discovery peer
mdns_discovery:
  id: peer_discovery
  service_type: "_intercom._udp"
  scan_interval: 10s
  peer_timeout: 60s
  on_peer_found:
    - logger.log:
        format: "Peer found: %s at %s"
        args: ['name.c_str()', 'ip.c_str()']
    - if:
        condition:
          lambda: 'return id(peer_discovery).get_peer_count() == 1;'
        then:
          - text.set:
              id: target_ip
              value: !lambda 'return id(peer_discovery).get_peer_ip(0);'
  on_peer_lost:
    - logger.log:
        format: "Peer lost: %s"
        args: ['name.c_str()']

sensor:
  - platform: mdns_discovery
    mdns_discovery_id: peer_discovery
    peer_count:
      name: "Peer Count"
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_bridge
    tx_packets:
      name: "TX Packets"
    rx_packets:
      name: "RX Packets"

text_sensor:
  - platform: mdns_discovery
    mdns_discovery_id: peer_discovery
    peers_list:
      name: "Discovered Peers"
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_bridge
    audio_mode:
      name: "Audio Mode"

text:
  - platform: template
    id: target_ip
    name: "Target IP"
    optimistic: true
    initial_value: "${go2rtc_server}"

# UN SOLO SELECT CON TRE MODALITÀ
select:
  - platform: template
    id: mode_select
    name: "Mode"
    options:
      - "go2rtc"
      - "p2p"
      - "p2p_auto_answer"
    initial_option: "go2rtc"
    on_value:
      then:
        - if:
            condition:
              lambda: 'return x == "go2rtc";'
            then:
              - text.set:
                  id: target_ip
                  value: "${go2rtc_server}"
        - if:
            condition:
              lambda: 'return x == "p2p" || x == "p2p_auto_answer";'
            then:
              - if:
                  condition:
                    lambda: 'return id(peer_discovery).get_peer_count() > 0;'
                  then:
                    - text.set:
                        id: target_ip
                        value: !lambda 'return id(peer_discovery).get_peer_ip(0);'

i2s_audio_udp:
  id: audio_bridge
  sample_rate: 16000
  mic_lrclk_pin: GPIO5
  mic_bclk_pin: GPIO6
  mic_din_pin: GPIO7
  mic_bits_per_sample: 32
  mic_channel: left
  mic_gain: 4
  speaker_lrclk_pin: GPIO8
  speaker_bclk_pin: GPIO9
  speaker_dout_pin: GPIO10
  speaker_enable_pin: GPIO46
  remote_ip: !lambda 'return id(target_ip).state;'
  remote_port: !lambda |-
    if (id(mode_select).state == "go2rtc") {
      return ${go2rtc_port};
    }
    return ${p2p_port};
  listen_port: ${p2p_port}
  on_start:
    - logger.log: "Streaming started"
  on_stop:
    - logger.log: "Streaming stopped"

number:
  - platform: i2s_audio_udp
    i2s_audio_udp_id: audio_bridge
    volume:
      name: "Volume"

# UDP per signaling P2P
udp:
  - id: signaling
    port: 12300
    on_receive:
      then:
        - lambda: |-
            std::string msg(x.begin(), x.end());
            ESP_LOGI("p2p", "Received: %s from %s", msg.c_str(), remote_ip.c_str());
            
            if (msg.rfind("RING:", 0) == 0) {
              id(incoming_caller_ip) = remote_ip.c_str();
              id(incoming_call).publish_state(true);
            } else if (msg == "HANGUP") {
              id(audio_bridge).stop();
            } else if (msg == "ACCEPT") {
              id(audio_bridge).start();
            }

globals:
  - id: incoming_caller_ip
    type: std::string

binary_sensor:
  - platform: template
    id: incoming_call
    name: "Incoming Call"
    on_press:
      then:
        - if:
            condition:
              lambda: 'return id(mode_select).state == "p2p_auto_answer";'
            then:
              - delay: 100ms
              - text.set:
                  id: target_ip
                  value: !lambda 'return id(incoming_caller_ip);'
              - udp.send:
                  id: signaling
                  destination: !lambda 'return id(incoming_caller_ip);'
                  port: 12300
                  data: "ACCEPT"
              - i2s_audio_udp.start: audio_bridge
    on_release:
      then:
        - i2s_audio_udp.stop: audio_bridge

switch:
  - platform: template
    name: "Call"
    id: call_switch
    turn_on_action:
      - if:
          condition:
            lambda: 'return id(mode_select).state != "go2rtc";'
          then:
            - udp.send:
                id: signaling
                destination: !lambda 'return id(target_ip).state;'
                port: 12300
                data: !lambda |-
                  return "RING:" + std::string(WiFi.localIP().toString().c_str());
            - delay: 200ms
      - i2s_audio_udp.start: audio_bridge
    turn_off_action:
      - if:
          condition:
            lambda: 'return id(mode_select).state != "go2rtc";'
          then:
            - udp.send:
                id: signaling
                destination: !lambda 'return id(target_ip).state;'
                port: 12300
                data: "HANGUP"
      - i2s_audio_udp.stop: audio_bridge
    lambda: 'return id(audio_bridge).is_streaming();'
```

### Task 4.6: Esempio con AEC

```yaml
# examples/with_aec.yaml

esp_aec:
  id: my_aec
  sample_rate: 16000

i2s_audio_udp:
  id: audio_bridge
  sample_rate: 16000
  i2s_lrclk_pin: GPIO45
  i2s_bclk_pin: GPIO9
  i2s_mclk_pin: GPIO16
  i2s_din_pin: GPIO10
  i2s_dout_pin: GPIO8
  speaker_enable_pin: GPIO46
  mic_bits_per_sample: 16
  mic_gain: 1
  aec_id: my_aec
  remote_ip: "192.168.1.50"
  remote_port: 12345
  listen_port: 12346
```

---

## FASE 5: Documentazione

### Task 5.1: README per ogni componente

Ogni componente deve avere un README.md con:
1. Descrizione (UNA cosa che fa)
2. Requisiti
3. Installazione
4. Configurazione completa
5. Deduzione automatica (per i2s_audio_udp)
6. Actions disponibili
7. Sensori/Number esposti
8. Triggers
9. Esempi
10. Metodi Lambda (per casi avanzati)
11. Note per contribuire

### Task 5.2: Documentazione stile ESPHome

Prepara file `.rst` per esphome-docs se punti a upstream.

---

## FASE 6: Testing

### Task 6.1: Test compilazione

```bash
esphome compile examples/go2rtc_full_duplex_dual.yaml
esphome compile examples/go2rtc_full_duplex_single.yaml
esphome compile examples/baby_monitor_mic.yaml
esphome compile examples/baby_monitor_speaker.yaml
esphome compile examples/p2p_intercom.yaml
esphome compile examples/with_aec.yaml
```

### Task 6.2: Test funzionale

**`i2s_audio_udp`:**
- [ ] Deduzione automatica I2S mode corretta (single/dual)
- [ ] Deduzione automatica audio mode corretta (TX/RX/Full Duplex)
- [ ] Stream audio bidirezionale funziona (Full Duplex)
- [ ] TX Only funziona (solo mic)
- [ ] RX Only funziona (solo speaker)
- [ ] Valori templatable vengono valutati a `start()`
- [ ] Actions `i2s_audio_udp.start` e `i2s_audio_udp.stop` funzionano
- [ ] Triggers vengono chiamati
- [ ] Sensori TX/RX packets si aggiornano
- [ ] Number volume funziona
- [ ] Text sensor audio_mode mostra valore corretto

**`mdns_discovery`:**
- [ ] Trova peer sulla rete
- [ ] Triggers funzionano
- [ ] Action `mdns_discovery.scan` funziona
- [ ] Sensori si aggiornano

**`esp_aec`:**
- [ ] Si inizializza correttamente
- [ ] Riduce echo

### Task 6.3: Test integrazione

- [ ] go2rtc riceve/invia audio
- [ ] Due ESP32 comunicano in P2P
- [ ] Handshake UDP funziona
- [ ] Cambio modalità aggiorna IP/porte
- [ ] Auto-answer funziona in `p2p_auto_answer`
- [ ] Baby monitor (TX + RX separati) funziona

---

## FASE 7: Preparazione per Pull Request

### Task 7.1: Verifica conformità ESPHome

- [ ] Struttura directory corretta
- [ ] Naming conventions rispettate
- [ ] Codice formattato
- [ ] Nessun warning
- [ ] Commenti in inglese
- [ ] License headers

### Task 7.2: Separa i componenti per PR

Ordine:
1. `esp_aec`
2. `mdns_discovery`
3. `i2s_audio_udp`

### Task 7.3: Test hardware multiplo

- [ ] ESP32
- [ ] ESP32-S3
- [ ] Single bus (ES8311)
- [ ] Dual bus (INMP441 + MAX98357A)
- [ ] TX Only
- [ ] RX Only
- [ ] Full Duplex

---

## Checklist Finale

### `i2s_audio_udp`

- [ ] `loop()` VUOTO
- [ ] Nessun parametro `i2s_mode` - dedotto automaticamente
- [ ] Nessun parametro `audio_mode` - dedotto automaticamente
- [ ] Nessuna logica P2P/discovery/auto-answer
- [ ] Deduce I2S mode (single/dual) dai pin dichiarati
- [ ] Deduce audio mode (TX/RX/Full Duplex) dai pin dichiarati
- [ ] Validazione: non mescolare pin i2s_* con mic_*/speaker_*
- [ ] Supporta TX Only, RX Only, Full Duplex
- [ ] Actions: `i2s_audio_udp.start`, `i2s_audio_udp.stop`
- [ ] Sensori: tx_packets, rx_packets
- [ ] Number: volume
- [ ] Text sensor: audio_mode
- [ ] Templatable: remote_ip, remote_port, listen_port

### `mdns_discovery`

- [ ] Solo query mDNS
- [ ] Action: `mdns_discovery.scan`
- [ ] Sensore: peer_count
- [ ] Text sensor: peers_list
- [ ] Triggers: on_peer_found, on_peer_lost, on_scan_complete

### `esp_aec`

- [ ] Wrapper minimale
- [ ] setup() init, loop() vuoto
- [ ] process(), get_frame_size()

### Esempi YAML

- [ ] Compilano tutti
- [ ] Coprono: go2rtc (single e dual bus), P2P, P2P auto-answer, TX Only, RX Only, AEC
- [ ] Nessun parametro i2s_mode negli esempi
- [ ] Usano `switch.is_on` per switch (nativo)
- [ ] Usano lambda per select (necessario)
- [ ] Un solo select con tre modalità

---

## Modalità di Lavoro

**Lavora in autonomia.** Non fermarti a chiedere conferme tra una fase e l'altra. Completa tutto il refactoring dall'inizio alla fine:

1. Analizza il codice esistente
2. Crea la struttura directory dei tre componenti
3. Implementa `esp_aec`
4. Implementa `mdns_discovery`
5. Implementa `i2s_audio_udp`
6. Crea tutti gli esempi YAML
7. Crea i README
8. Verifica che tutto compili

**Quando hai finito tutto**, mostrami:
- Struttura directory finale
- Eventuali problemi riscontrati e come li hai risolti
- Istruzioni per testare

**Non chiedere conferme intermedie.** Se hai dubbi su qualcosa, prendi la decisione che ritieni migliore seguendo i principi di questo prompt (componente stupido, logica in YAML, best practices ESPHome, deduzione automatica). Documenta le scelte che hai fatto nel README.

**Se incontri errori di compilazione**, risolvili autonomamente e vai avanti ma avverti se risulta impossibile seguire uno di questi dettami.
Hai a disposizione la palletta cinese collegata a questo pc via usb oterrà ip 192.168.1.31 puoi rinominare il prgetto in i2s_audio_udp invece che esp32_intercom hai l'altro dispositivo per fare test esp-mini su ip 192.168.1.18. In questa cartella c'è una venv che avevi fatto con esphome per compilare attraverso questo pc, hai accesso alla lxc di home assistant come root@192.168.1.10 contiene hass installato via pip c'è gia go2rtc che avevi messo su e altre cose, occupati solo di sfruttarlo per provare modalita e tasti non crearmi automazioni o altro che potrebbe sporcare la mia installazione invece per i due esp con cui devi fare le prove puoi fare tutto.
